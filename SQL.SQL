CREATE TABLE SA_JS_JO_NR_REGIONES( --MANTENEDOR LISTO
	COD_REGION NUMBER,
	NOMBRE_REGION VARCHAR2(50),
	CONSTRAINT PK_SA_JS_JO_NR_REGIONES PRIMARY KEY(COD_REGION)
);

CREATE TABLE SA_JS_JO_NR_DIRECCIONES( --MANTENEDOR LISTO
	COD_CALLEN NUMBER,
	CALLE_DIRECCION VARCHAR2(60),
	NUMERO_DIRECCION NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECCIONES PRIMARY KEY(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_COMUNAS( --MANTENEDOR LISTO
	COD_COMUNA NUMBER,
	NOMBRE_COMUNA VARCHAR2(60),
	COD_REGION NUMBER,
	COD_CALLEN NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMUNAS PRIMARY KEY(COD_COMUNA),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_DIRECCIONES FOREIGN KEY(COD_CALLEN) REFERENCES SA_JS_JO_NR_DIRECCIONES(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_TIPO_CUOTAS( --MANTENEDOR LISTO
	COD_TIPO_CUOTA NUMBER,
	TIPO_CUOTA VARCHAR2(20),
	MONTO_CUOTA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_TIPO_CUOTAS PRIMARY KEY(COD_TIPO_CUOTA)
);

CREATE TABLE SA_JS_JO_NR_SERVICIOS( --MANTENEDOR LISTO
	COD_SERVICIO NUMBER,
	NOMBRE_SERVICIO VARCHAR2(40),
	CONSTRAINT PK_SA_JS_JO_NR_SERVICIOS PRIMARY KEY(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_CUOTAS( --MANTENEDOR LISTO
	COD_CUOTA NUMBER,
	COD_TIPO_CUOTA NUMBER,
	TOTAL_CUOTA NUMBER, --REVISAR
	FECHA_VENCIMIENTO_CUOTA DATE,
	COD_SERVICIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CUOTAS PRIMARY KEY(COD_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_TIPO_CUOTAS FOREIGN KEY(COD_TIPO_CUOTA) REFERENCES SA_JS_JO_NR_TIPO_CUOTAS(COD_TIPO_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_SERVICIOS FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_PREDIOS( --MANTENEDOR LISTO
	COD_CUOTA NUMBER,
	COD_PREDIO NUMBER, 
	ROL_PREDIO NUMBER,
	HECTAREAS_PREDIO NUMBER,
	ACCIONES_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PREDIOS PRIMARY KEY(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_USUARIOS( --MANTENEDOR LISTO
	RUT_USUARIO NUMBER,
    ROL VARCHAR2(10),
	NOMBRE_USUARIO VARCHAR2(100),
	APELLIDO1_USUARIO VARCHAR2(50),
	APELLIDO2_USUARIO VARCHAR2(50),
	COD_REGION NUMBER,
	CORREO_USUARIO VARCHAR2(100),
	TELEFONO_USUARIO NUMBER,
	COD_CUOTA NUMBER,
	COD_PREDIO NUMBER,
    DEUDA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_USUARIOS PRIMARY KEY(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_CUOTAS FOREIGN KEY(COD_CUOTA) REFERENCES SA_JS_JO_NR_CUOTAS(COD_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_PAGOS(
	COD_HISTORIAL_PAGO NUMBER,
	NOMBRE_PAGADOR VARCHAR2(100),
	DETALLE_PAGO VARCHAR2(200),
	FECHA_PAGO DATE,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_PAGOS PRIMARY KEY(COD_HISTORIAL_PAGO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_PAGOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_CAMBIOS(
	COD_HISTORIAL_CAMBIO NUMBER,
	DETALLE_CAMBIO VARCHAR2(200),
	FECHA_CAMBIO DATE,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_CAMBIOS PRIMARY KEY(COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_CAMBIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)	
);

CREATE TABLE SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS(
	RUT_USUARIO NUMBER,
	COD_HISTORIAL_CAMBIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS PRIMARY KEY(RUT_USUARIO, COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS_USUARIOS FOREIGN KEY(RUT_USUARIO) REFERENCES SA_JS_JO_NR_USUARIOS(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS_HISTORIAL_CAMBIOS FOREIGN KEY(COD_HISTORIAL_CAMBIO) REFERENCES SA_JS_JO_NR_HISTORIAL_CAMBIOS(COD_HISTORIAL_CAMBIO)
);

CREATE TABLE SA_JS_JO_NR_SUBZONAS( --MANTENEDOR LISTO
	COD_SUBZONA NUMBER,
	NOMBRE_SUBZONA VARCHAR2(150),
	CONSTRAINT PK_SA_JS_JO_NR_SUBZONAS PRIMARY KEY(COD_SUBZONA)
);

CREATE TABLE SA_JS_JO_NR_ZONAS( --MANTENEDOR LISTO
	COD_ZONA NUMBER,
	NOMBRE_ZONA VARCHAR2(150),
	COD_SUBZONA NUMBER,
	COD_COMUNA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_ZONAS PRIMARY KEY(COD_ZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_SUBZONAS FOREIGN KEY(COD_SUBZONA) REFERENCES SA_JS_JO_NR_SUBZONAS(COD_SUBZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_COMUNAS FOREIGN KEY(COD_COMUNA) REFERENCES SA_JS_JO_NR_COMUNAS(COD_COMUNA)
);

CREATE TABLE SA_JS_JO_NR_SECTORES( --MANTENEDOR LISTO
	COD_SECTOR NUMBER, 
	NOMBRE_SECTOR VARCHAR2(100),
	COD_ZONA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_SECTORES PRIMARY KEY(COD_SECTOR),
	CONSTRAINT FK_SA_JS_JO_NR_SECTORES_ZONAS FOREIGN KEY(COD_ZONA) REFERENCES SA_JS_JO_NR_ZONAS(COD_ZONA)
);

CREATE TABLE SA_JS_JO_NR_CANALES( --MANTENEDOR LISTO
	COD_CANAL NUMBER,
	NOMBRE_CANAL VARCHAR2(100),
	FACTOR_CANAL NUMBER,
	COD_SECTOR NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CANALES PRIMARY KEY(COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_CANALES_SECTORES FOREIGN KEY(COD_SECTOR) REFERENCES SA_JS_JO_NR_SECTORES(COD_SECTOR)
);

CREATE TABLE SA_JS_JO_NR_DIRECTIVAS( --MANTENEDOR LISTO
	COD_DIRECTIVA NUMBER,
	NOMBRE_DIRECTIVA VARCHAR2(100),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECTIVAS PRIMARY KEY(COD_DIRECTIVA),
	CONSTRAINT FK_SA_JS_JO_NR_DIRECTIVAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PRESIDENTES( --MANTENEDOR LISTO
	COD_PRESIDENTE NUMBER,
	NOMBRE_PRESIDENTE VARCHAR2(100),
	APELLIDO1_PRESIDENTE VARCHAR2(50),
	APELLIDO2_PRESIDENTE VARCHAR2(50),
	COD_DIRECTIVA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PRESIDENTES PRIMARY KEY(COD_PRESIDENTE),
	CONSTRAINT FK_SA_JS_JO_NR_PRESIDENTES_DIRECTIVAS FOREIGN KEY(COD_DIRECTIVA) REFERENCES SA_JS_JO_NR_DIRECTIVAS(COD_DIRECTIVA)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_SERVICIO_CANALES(
	COD_SERVICIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES PRIMARY KEY(COD_SERVICIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES_SERVICIOS FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_PREDIO_CANALES(
	COD_PREDIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES PRIMARY KEY(COD_PREDIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PROYECTOS( --MANTENEDOR LISTO
	COD_PROYECTO NUMBER,
	NOMBRE_PROYECTO VARCHAR2(100),
	DESCRIPCION_PROYECTO VARCHAR2(200),
	FECHA_INICIO_PROYECTO DATE,
	FECHA_FIN_PROYECTO DATE,
	ESTADO_PROYECTO VARCHAR2(20),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PROYECTOS PRIMARY KEY(COD_PROYECTO),
	CONSTRAINT FK_SA_JS_JO_NR_PROYECTOS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_COMPUERTAS( --MANTENEDOR LISTO
	COD_COMPUERTA NUMBER,
	KILOMETRAJE_COMPUERTA NUMBER,
	DESCRIPCION_COMPUERTA VARCHAR2(200),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMPUERTAS PRIMARY KEY(COD_COMPUERTA),
	CONSTRAINT FK_SA_JS_JO_NR_COMPUERTAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_CELADORES( --MANTENEDOR LISTO
	COD_CELADOR NUMBER,
	NOMBRE_CELADOR VARCHAR2(100),
	APELLIDO1_CELADOR VARCHAR2(50),
	APELLIDO2_CELADOR VARCHAR2(50),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CELADORES PRIMARY KEY(COD_CELADOR),
	CONSTRAINT FK_SA_JS_JO_NR_CELADORES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);


-- Triggers (2 por ahora)

-- función: verifica que existan los codigos de region y de calle asociados a la comuna que se inserte o actualice en las tablas de regiones y direcciones
CREATE OR REPLACE TRIGGER SA_JS_JO_NR_trg_verifica_integridad_comunas
BEFORE INSERT OR UPDATE ON SA_JS_JO_NR_COMUNAS
FOR EACH ROW
DECLARE
    v_region_exists NUMBER;
    v_direccion_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_region_exists
    FROM SA_JS_JO_NR_REGIONES
    WHERE COD_REGION = :NEW.COD_REGION;

    IF v_region_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'La región no existe :,v.');
    END IF;

    SELECT COUNT(*) INTO v_direccion_exists
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = :NEW.COD_CALLEN;

    IF v_direccion_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'La dirección no existe papu :c.');
    END IF;
END;
/

-- funcion: verifica que no haya ninguna comuna asociada a la region que se desea eliminar, si existe entonces no se elimna
CREATE OR REPLACE TRIGGER SA_JS_JO_NR_trg_prevenir_eliminacion_region
BEFORE DELETE ON SA_JS_JO_NR_REGIONES
FOR EACH ROW
DECLARE
    v_comuna_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_comuna_exists
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_REGION = :OLD.COD_REGION;

    IF v_comuna_exists > 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'No se puede eliminar la región porque tiene comunas dentro de ella. Borra la/s comunas primero');
    END IF;
END;
/

-- MANTENEDORES

-- REGIONES
CREATE OR REPLACE PROCEDURE AGREGAR_REGIONES(
    P_NOMBRE_REGION VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_REGION),0)+1 INTO PK
    FROM SA_JS_JO_NR_REGIONES;
 
	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_REGIONES (COD_REGION, NOMBRE_REGION)
    VALUES (PK, P_NOMBRE_REGION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501,'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010,'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_REGIONES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_REGION, NOMBRE_REGION FROM SA_JS_JO_NR_REGIONES;
END LEER_REGIONES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_REGION(
    P_COD_REGION NUMBER,
    P_NOMBRE_REGION VARCHAR2
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

	IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Región no encontrada');
    
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	UPDATE SA_JS_JO_NR_REGIONES
    	SET NOMBRE_REGION = P_NOMBRE_REGION
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_REGION(
    P_COD_REGION NUMBER
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

    IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Región no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	DELETE FROM SA_JS_JO_NR_REGIONES
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
	WHEN OTHERS THEN
        ROLLBACK;
    	RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

--DIRECCIONES
CREATE OR REPLACE PROCEDURE AGREGAR_DIRECCIONES(
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CALLEN),0)+1 INTO PK
    FROM SA_JS_JO_NR_DIRECCIONES;

	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_DIRECCIONES (COD_CALLEN, CALLE_DIRECCION, NUMERO_DIRECCION)
    VALUES (PK, P_CALLE_DIRECCION, P_NUMERO_DIRECCION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECCIONES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CALLEN, CALLE_DIRECCION, NUMERO_DIRECCION FROM SA_JS_JO_NR_DIRECCIONES;
END LEER_DIRECCIONES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECCIONES(
    P_COD_CALLEN NUMBER,
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        UPDATE SA_JS_JO_NR_DIRECCIONES
        SET CALLE_DIRECCION = P_CALLE_DIRECCION,
            NUMERO_DIRECCION = P_NUMERO_DIRECCION
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECCIONES(
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        DELETE FROM SA_JS_JO_NR_DIRECCIONES
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

-- COMUNAS 
CREATE OR REPLACE PROCEDURE AGREGAR_COMUNAS(
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_COMUNA),0)+1 INTO PK
    FROM SA_JS_JO_NR_COMUNAS;

	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_COMUNAS (COD_COMUNA, NOMBRE_COMUNA, COD_REGION, COD_CALLEN)
    VALUES (PK, P_NOMBRE_COMUNA, P_COD_REGION, P_COD_CALLEN);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la comuna');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMUNAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_COMUNA, NOMBRE_COMUNA, COD_REGION, COD_CALLEN FROM SA_JS_JO_NR_COMUNAS;
END LEER_COMUNAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMUNAS(
    P_COD_COMUNA NUMBER,
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_COMUNAS
        SET NOMBRE_COMUNA = P_NOMBRE_COMUNA,
            COD_REGION = P_COD_REGION,
            COD_CALLEN = P_COD_CALLEN
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la comuna');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMUNAS(
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_COMUNAS
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la comuna');
END;
/

-- TIPO CUOTAS
CREATE OR REPLACE PROCEDURE AGREGAR_TIPO_CUOTAS(
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_TIPO_CUOTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_TIPO_CUOTAS;

	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_TIPO_CUOTAS (COD_TIPO_CUOTA, TIPO_CUOTA, MONTO_CUOTA)
    VALUES (PK, P_TIPO_CUOTA, P_MONTO_CUOTA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_TIPO_CUOTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_TIPO_CUOTA, TIPO_CUOTA, MONTO_CUOTA FROM SA_JS_JO_NR_TIPO_CUOTAS;
END LEER_TIPO_CUOTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_TIPO_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER,
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTAS
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_TIPO_CUOTAS
        SET TIPO_CUOTA = P_TIPO_CUOTA,
            MONTO_CUOTA = P_MONTO_CUOTA
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_TIPO_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTAS
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_TIPO_CUOTAS
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del tipo de cuota');
END;
/

-- SERVICIOS
CREATE OR REPLACE PROCEDURE AGREGAR_SERVICIOS(
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SERVICIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_SERVICIOS;

	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_SERVICIOS (COD_SERVICIO, NOMBRE_SERVICIO)
    VALUES (PK, P_NOMBRE_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el servicio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SERVICIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SERVICIO, NOMBRE_SERVICIO FROM SA_JS_JO_NR_SERVICIOS;
END LEER_SERVICIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SERVICIOS(
    P_COD_SERVICIO NUMBER,
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_SERVICIOS
        SET NOMBRE_SERVICIO = P_NOMBRE_SERVICIO
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del servicio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SERVICIOS(
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_SERVICIOS
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del servicio');
END;
/

-- CUOTAS
CREATE OR REPLACE PROCEDURE AGREGAR_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CUOTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_CUOTAS;

	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_CUOTAS (COD_CUOTA, COD_TIPO_CUOTA, TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA, COD_SERVICIO)
    VALUES (PK, P_COD_TIPO_CUOTA, P_TOTAL_CUOTA, P_FECHA_VENCIMIENTO_CUOTA, P_COD_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CUOTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CUOTA, COD_TIPO_CUOTA, TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA, COD_SERVICIO 
        FROM SA_JS_JO_NR_CUOTAS;
END LEER_CUOTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CUOTAS(
    P_COD_CUOTA NUMBER,
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_CUOTAS
        SET COD_TIPO_CUOTA = P_COD_TIPO_CUOTA,
            TOTAL_CUOTA = P_TOTAL_CUOTA,
            FECHA_VENCIMIENTO_CUOTA = P_FECHA_VENCIMIENTO_CUOTA,
            COD_SERVICIO = P_COD_SERVICIO
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CUOTAS(
    P_COD_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_CUOTAS
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la cuota');
END;
/

--PREDIOS
CREATE OR REPLACE PROCEDURE AGREGAR_PREDIOS(
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PREDIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_PREDIOS;

	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_PREDIOS (COD_PREDIO, ROL_PREDIO, HECTAREAS_PREDIO, ACCIONES_PREDIO)
    VALUES (PK, P_ROL_PREDIO, P_HECTAREAS_PREDIO, P_ACCIONES_PREDIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el predio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PREDIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PREDIO, ROL_PREDIO, HECTAREAS_PREDIO, ACCIONES_PREDIO FROM SA_JS_JO_NR_PREDIOS;
END LEER_PREDIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PREDIOS(
    P_COD_PREDIO NUMBER,
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_PREDIOS
        SET ROL_PREDIO = P_ROL_PREDIO,
            HECTAREAS_PREDIO = P_HECTAREAS_PREDIO,
            ACCIONES_PREDIO = P_ACCIONES_PREDIO
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del predio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PREDIOS(
    P_COD_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_PREDIOS
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del predio');
END;
/

-- USUARIOS
CREATE OR REPLACE PROCEDURE AGREGAR_USUARIOS(
    P_RUT_USUARIO NUMBER,
    P_NOMBRE_USUARIO VARCHAR2,
    P_ROL VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_COD_PREDIO NUMBER,
    P_DEUDA NUMBER
) 
IS
    --DECLARE PK NUMBER := 0;
BEGIN
    /*SELECT NVL(MAX(RUT_USUARIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_USUARIO;
    -- Bloqueo de la tabla para control de concurrencia
    
*/
    LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_USUARIOS (
        RUT_USUARIO, ROL, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO,
        COD_REGION, CORREO_USUARIO, TELEFONO_USUARIO, COD_CUOTA, COD_PREDIO, DEUDA
    )
    VALUES (
        P_RUT_USUARIO, P_ROL, P_NOMBRE_USUARIO, P_APELLIDO1_USUARIO, 
        P_APELLIDO2_USUARIO, P_COD_REGION, P_CORREO_USUARIO, P_TELEFONO_USUARIO, 
        P_COD_CUOTA, P_COD_PREDIO, P_DEUDA
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el usuario');
END;
/

CREATE OR REPLACE PROCEDURE LEER_USUARIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT RUT_USUARIO, ROL, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO, 
               COD_REGION, CORREO_USUARIO, TELEFONO_USUARIO, COD_CUOTA, COD_PREDIO, DEUDA
        FROM SA_JS_JO_NR_USUARIOS;
END LEER_USUARIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_USUARIOS(
    P_RUT_USUARIO NUMBER,
    P_ROL VARCHAR2,
    P_NOMBRE_USUARIO VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_COD_PREDIO NUMBER,
    P_DEUDA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIOS
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_USUARIOS
        SET NOMBRE_USUARIO = P_NOMBRE_USUARIO,
            ROL = P_ROL,
            APELLIDO1_USUARIO = P_APELLIDO1_USUARIO,
            APELLIDO2_USUARIO = P_APELLIDO2_USUARIO,
            COD_REGION = P_COD_REGION,
            CORREO_USUARIO = P_CORREO_USUARIO,
            TELEFONO_USUARIO = P_TELEFONO_USUARIO,
            COD_CUOTA = P_COD_CUOTA,
            COD_PREDIO = P_COD_PREDIO,
            DEUDA = P_DEUDA
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del usuario');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_USUARIOS(
    P_RUT_USUARIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIOS
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_USUARIOS
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del usuario');
END;
/

-- SUBZONAS
CREATE OR REPLACE PROCEDURE AGREGAR_SUBZONAS(
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SUBZONA),0)+1 INTO PK
    FROM SA_JS_JO_NR_SUBZONAS;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SUBZONAS (COD_SUBZONA, NOMBRE_SUBZONA)
    VALUES (PK, P_NOMBRE_SUBZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la subzona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SUBZONAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SUBZONA, NOMBRE_SUBZONA FROM SA_JS_JO_NR_SUBZONAS;
END LEER_SUBZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SUBZONAS(
    P_COD_SUBZONA NUMBER,
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SUBZONAS
        SET NOMBRE_SUBZONA = P_NOMBRE_SUBZONA
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la subzona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SUBZONAS(
    P_COD_SUBZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SUBZONAS
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la subzona');
END;
/

-- ZONAS
CREATE OR REPLACE PROCEDURE AGREGAR_ZONAS(
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_ZONA),0)+1 INTO PK
    FROM SA_JS_JO_NR_ZONAS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_ZONAS (COD_ZONA, NOMBRE_ZONA, COD_SUBZONA, COD_COMUNA)
    VALUES (PK, P_NOMBRE_ZONA, P_COD_SUBZONA, P_COD_COMUNA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la zona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_ZONAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_ZONA, NOMBRE_ZONA, COD_SUBZONA, COD_COMUNA FROM SA_JS_JO_NR_ZONAS;
END LEER_ZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_ZONAS(
    P_COD_ZONA NUMBER,
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_ZONAS
        SET NOMBRE_ZONA = P_NOMBRE_ZONA,
            COD_SUBZONA = P_COD_SUBZONA,
            COD_COMUNA = P_COD_COMUNA
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la zona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_ZONAS(
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_ZONAS
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la zona');
END;
/

-- SECTORES
CREATE OR REPLACE PROCEDURE AGREGAR_SECTORES(
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SECTOR),0)+1 INTO PK
    FROM SA_JS_JO_NR_SECTORES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SECTORES (COD_SECTOR, NOMBRE_SECTOR, COD_ZONA)
    VALUES (PK, P_NOMBRE_SECTOR, P_COD_ZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el sector');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SECTORES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SECTOR, NOMBRE_SECTOR, COD_ZONA FROM SA_JS_JO_NR_SECTORES;
END LEER_SECTORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SECTORES(
    P_COD_SECTOR NUMBER,
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SECTORES
        SET NOMBRE_SECTOR = P_NOMBRE_SECTOR,
            COD_ZONA = P_COD_ZONA
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del sector');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SECTORES(
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SECTORES
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del sector');
END;
/

-- CANALES
CREATE OR REPLACE PROCEDURE AGREGAR_CANALES(
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CANAL),0)+1 INTO PK
    FROM SA_JS_JO_NR_CANALES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CANALES (COD_CANAL, NOMBRE_CANAL, FACTOR_CANAL, COD_SECTOR)
    VALUES (PK, P_NOMBRE_CANAL, P_FACTOR_CANAL, P_COD_SECTOR);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el canal');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CANALES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CANAL, NOMBRE_CANAL, FACTOR_CANAL, COD_SECTOR FROM SA_JS_JO_NR_CANALES;
END LEER_CANALES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CANALES(
    P_COD_CANAL NUMBER,
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CANALES
        SET NOMBRE_CANAL = P_NOMBRE_CANAL,
            FACTOR_CANAL = P_FACTOR_CANAL,
            COD_SECTOR = P_COD_SECTOR
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del canal');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CANALES(
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CANALES
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del canal');
END;
/

-- DIRECTIVAS
CREATE OR REPLACE PROCEDURE AGREGAR_DIRECTIVAS(
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_DIRECTIVA),0)+1 INTO PK
    FROM SA_JS_JO_NR_DIRECTIVAS;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_DIRECTIVAS (COD_DIRECTIVA, NOMBRE_DIRECTIVA, COD_CANAL)
    VALUES (PK, P_NOMBRE_DIRECTIVA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la directiva');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECTIVAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_DIRECTIVA, NOMBRE_DIRECTIVA, COD_CANAL FROM SA_JS_JO_NR_DIRECTIVAS;
END LEER_DIRECTIVAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECTIVAS(
    P_COD_DIRECTIVA NUMBER,
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_DIRECTIVAS
        SET NOMBRE_DIRECTIVA = P_NOMBRE_DIRECTIVA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la directiva');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECTIVAS(
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_DIRECTIVAS
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la directiva');
END;
/

-- PRESIDENTES
CREATE OR REPLACE PROCEDURE AGREGAR_PRESIDENTES(
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PRESIDENTE),0)+1 INTO PK
    FROM SA_JS_JO_NR_PRESIDENTES;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PRESIDENTES (COD_PRESIDENTE, NOMBRE_PRESIDENTE, APELLIDO1_PRESIDENTE, APELLIDO2_PRESIDENTE, COD_DIRECTIVA)
    VALUES (PK, P_NOMBRE_PRESIDENTE, P_APELLIDO1_PRESIDENTE, P_APELLIDO2_PRESIDENTE, P_COD_DIRECTIVA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el presidente');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PRESIDENTES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PRESIDENTE, NOMBRE_PRESIDENTE, APELLIDO1_PRESIDENTE, APELLIDO2_PRESIDENTE, COD_DIRECTIVA 
        FROM SA_JS_JO_NR_PRESIDENTES;
END LEER_PRESIDENTES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PRESIDENTES(
    P_COD_PRESIDENTE NUMBER,
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PRESIDENTES
        SET NOMBRE_PRESIDENTE = P_NOMBRE_PRESIDENTE,
            APELLIDO1_PRESIDENTE = P_APELLIDO1_PRESIDENTE,
            APELLIDO2_PRESIDENTE = P_APELLIDO2_PRESIDENTE,
            COD_DIRECTIVA = P_COD_DIRECTIVA
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del presidente');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PRESIDENTES(
    P_COD_PRESIDENTE NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PRESIDENTES
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del presidente');
END;
/

-- PROYECTOS
CREATE OR REPLACE PROCEDURE AGREGAR_PROYECTOS(
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PROYECTO),0)+1 INTO PK
    FROM SA_JS_JO_NR_PROYECTOS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PROYECTOS (
        COD_PROYECTO, NOMBRE_PROYECTO, DESCRIPCION_PROYECTO, 
        FECHA_INICIO_PROYECTO, FECHA_FIN_PROYECTO, ESTADO_PROYECTO, COD_CANAL
    )
    VALUES (
        PK, P_NOMBRE_PROYECTO, P_DESCRIPCION_PROYECTO, 
        P_FECHA_INICIO_PROYECTO, P_FECHA_FIN_PROYECTO, P_ESTADO_PROYECTO, P_COD_CANAL
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el proyecto');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PROYECTOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PROYECTO, NOMBRE_PROYECTO, DESCRIPCION_PROYECTO, 
               FECHA_INICIO_PROYECTO, FECHA_FIN_PROYECTO, ESTADO_PROYECTO, COD_CANAL 
        FROM SA_JS_JO_NR_PROYECTOS;
END LEER_PROYECTOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PROYECTOS(
    P_COD_PROYECTO NUMBER,
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PROYECTOS
        SET NOMBRE_PROYECTO = P_NOMBRE_PROYECTO,
            DESCRIPCION_PROYECTO = P_DESCRIPCION_PROYECTO,
            FECHA_INICIO_PROYECTO = P_FECHA_INICIO_PROYECTO,
            FECHA_FIN_PROYECTO = P_FECHA_FIN_PROYECTO,
            ESTADO_PROYECTO = P_ESTADO_PROYECTO,
            COD_CANAL = P_COD_CANAL
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del proyecto');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PROYECTOS(
    P_COD_PROYECTO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PROYECTOS
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del proyecto');
END;
/

-- COMPUERTAS
CREATE OR REPLACE PROCEDURE AGREGAR_COMPUERTAS(
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_COMPUERTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_COMPUERTAS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_COMPUERTAS (COD_COMPUERTA, KILOMETRAJE_COMPUERTA, DESCRIPCION_COMPUERTA, COD_CANAL)
    VALUES (PK, P_KILOMETRAJE_COMPUERTA, P_DESCRIPCION_COMPUERTA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMPUERTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_COMPUERTA, KILOMETRAJE_COMPUERTA, DESCRIPCION_COMPUERTA, COD_CANAL FROM SA_JS_JO_NR_COMPUERTAS;
END LEER_COMPUERTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMPUERTAS(
    P_COD_COMPUERTA NUMBER,
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_COMPUERTAS
        SET KILOMETRAJE_COMPUERTA = P_KILOMETRAJE_COMPUERTA,
            DESCRIPCION_COMPUERTA = P_DESCRIPCION_COMPUERTA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMPUERTAS(
    P_COD_COMPUERTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_COMPUERTAS
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la compuerta');
END;
/

-- CELADORES
CREATE OR REPLACE PROCEDURE AGREGAR_CELADORES(
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CELADOR),0)+1 INTO PK
    FROM SA_JS_JO_NR_CELADORES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CELADORES (COD_CELADOR, NOMBRE_CELADOR, APELLIDO1_CELADOR, APELLIDO2_CELADOR, COD_CANAL)
    VALUES (PK, P_NOMBRE_CELADOR, P_APELLIDO1_CELADOR, P_APELLIDO2_CELADOR, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el celador');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CELADORES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CELADOR, NOMBRE_CELADOR, APELLIDO1_CELADOR, APELLIDO2_CELADOR, COD_CANAL 
        FROM SA_JS_JO_NR_CELADORES;
END LEER_CELADORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CELADORES(
    P_COD_CELADOR NUMBER,
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CELADORES
        SET NOMBRE_CELADOR = P_NOMBRE_CELADOR,
            APELLIDO1_CELADOR = P_APELLIDO1_CELADOR,
            APELLIDO2_CELADOR = P_APELLIDO2_CELADOR,
            COD_CANAL = P_COD_CANAL
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del celador');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CELADORES(
    P_COD_CELADOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CELADORES
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del celador');
END;
/

-- Funciones

-- Funcion para calcular interes
CREATE OR REPLACE FUNCTION calcular_total_con_interes(
    p_cod_cuota NUMBER
) RETURN NUMBER IS
    v_total_con_interes NUMBER := 0;
    v_dias_vencidos NUMBER := 0;
    v_total_cuota NUMBER;
    v_fecha_vencimiento DATE;
BEGIN
    SELECT TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA 
    INTO v_total_cuota, v_fecha_vencimiento
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = p_cod_cuota;

    IF v_fecha_vencimiento < SYSDATE THEN
        v_dias_vencidos := SYSDATE - v_fecha_vencimiento;
    END IF;
    -- Calcular el total con interés (0.05% por día de atraso) (cambiar)
    v_total_con_interes := v_total_cuota + (v_total_cuota * 0.0005 * v_dias_vencidos);
    RETURN v_total_con_interes;
END;

-- EJEMPLO DE USO:
SELECT COD_CUOTA,
       TOTAL_CUOTA,
       calcular_total_con_interes(COD_CUOTA) AS TOTAL_CON_INTERES
FROM SA_JS_JO_NR_CUOTAS
WHERE COD_CUOTA = 101;  -- Reemplaza 101 con el código de la cuota que deseas consultar


-- fUNCION PARA VERIFICAR DISPONIBILIDAD DEL PROYECTO 
CREATE OR REPLACE FUNCTION verificar_disponibilidad_proyecto(
    p_cod_proyecto NUMBER
) RETURN BOOLEAN IS
    v_disponible BOOLEAN := TRUE;
    v_estado VARCHAR2(20);
    v_cuotas_vencidas NUMBER;
BEGIN
    -- Verificar si el proyecto está activo
    SELECT estado INTO v_estado
    FROM SA_JS_JO_NR_PROYECTOS  -- Suponiendo que existe una tabla de proyectos
    WHERE cod_proyecto = p_cod_proyecto;

    IF v_estado != 'Activo' THEN
        v_disponible := FALSE;
    END IF;
    RETURN v_disponible;
    verificar_disponibilidad_proyecto;
END;

/* GESTORES
1. Gestor de Cuotas Pendientes por Usuario
Este gestor calcula el total de cuotas pendientes por usuario. Puede ser útil para monitorear qué usuarios tienen pagos atrasados.
2. Gestor de Proyectos Activos por Canal
Este gestor obtiene la lista de proyectos activos (es decir, proyectos en curso) por cada canal.
3. Gestor de Historial de Pagos por Predio
Este gestor devuelve un historial de pagos para cada predio, útil para ver el historial de contribuciones de cada uno.
4. Gestor de Servicios por Canal
Este gestor muestra todos los servicios asociados a cada canal, mostrando su relación en detalle.
5. Gestor de Celadores por Canal
Este gestor muestra la lista de celadores asignados a cada canal, lo cual es útil para analizar la distribución de personal.*/

/* ideas gestores
-automatizacion para las tablas detalle_historial_usuario, historial_cambios, historial_pagos, detalle_servicio_canal y detalle_predio_canal
-calcular valor cuota en base al factor
*/
--detalle_historial_cambios
CREATE OR REPLACE SEQUENCE SEQ_HISTORIAL_CAMBIOS
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 1000
    CACHE 50
    NOCYCLE;

CREATE OR REPLACE TRIGGER trg_historial_cambios
AFTER UPDATE ON SA_JS_JO_NR_PREDIOS
FOR EACH ROW
DECLARE
    v_cod_historial_cambio NUMBER;
    v_rut_usuario NUMBER;
BEGIN
    -- Generar el próximo valor de la secuencia
    SELECT SEQ_HISTORIAL_CAMBIOS.NEXTVAL INTO v_cod_historial_cambio FROM DUAL;

    -- Obtener el RUT del usuario asociado al predio
    BEGIN
        SELECT RUT_USUARIO INTO v_rut_usuario
        FROM SA_JS_JO_NR_USUARIOS
        WHERE COD_PREDIO = :NEW.COD_PREDIO;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'No se encontró un usuario asociado al predio.');
    END;

    -- Insertar un nuevo registro en la tabla Historial_Cambios
    INSERT INTO SA_JS_JO_NR_HISTORIAL_CAMBIOS (
        COD_HISTORIAL_CAMBIO, COD_PREDIO, DETALLE_CAMBIO, FECHA_CAMBIO
    )
    VALUES (
        v_cod_historial_cambio,
        :NEW.COD_PREDIO,
        'Modificación en el predio: ' || :NEW.COD_PREDIO,
        SYSDATE
    );

/*    -- Insertar un registro en la tabla Detalle_Historial_Usuarios
    INSERT INTO SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS (
        RUT_USUARIO, COD_HISTORIAL_CAMBIO
    )
    VALUES (
        v_rut_usuario,
        v_cod_historial_cambio
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
/ */

-- historial pagos
CREATE OR REPLACE SEQUENCE SEQ_HISTORIAL_PAGOS
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 1000
    CACHE 50
    NOCYCLE;

CREATE OR REPLACE TRIGGER trg_actualizar_historial_pagos
AFTER UPDATE OF DEUDA ON SA_JS_JO_NR_USUARIOS
FOR EACH ROW
DECLARE
    v_cod_historial_pago NUMBER; -- Variable para almacenar el valor de la secuencia
    v_detalle_pago VARCHAR2(200); -- Variable para el mensaje del detalle
BEGIN
    IF :OLD.DEUDA > :NEW.DEUDA THEN
        SELECT SEQ_HISTORIAL_PAGOS.NEXTVAL INTO v_cod_historial_pago FROM DUAL;

        IF :NEW.DEUDA = 0 THEN
            v_detalle_pago := 'Se pagó la totalidad de la deuda de $' || :OLD.DEUDA || 'con exito.';
        ELSE
            v_detalle_pago := 'Se realizó un abono por $'|| (:NEW.DEUDA - :OLD.DEUDA) || '. Deuda restante ' || :NEW.DEUDA || '.';
        END IF;

        -- Insertar un registro en SA_JS_JO_NR_HISTORIAL_PAGOS
        INSERT INTO SA_JS_JO_NR_HISTORIAL_PAGOS (
            COD_HISTORIAL_PAGO, NOMBRE_PAGADOR, DETALLE_PAGO, FECHA_PAGO, COD_PREDIO
        )
        VALUES (
            v_cod_historial_pago,
            :NEW.NOMBRE_USUARIO || ' ' || :NEW.APELLIDO1_USUARIO || ' ' || :NEW.APELLIDO2_USUARIO,
            v_detalle_pago,
            SYSDATE,
            :NEW.COD_PREDIO
        );
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Error al registrar el pago en el historial.');
END;
/





--REPORTES
--1. Reporte de Usuarios y Cuotas Pendientes
--Este reporte muestra a los usuarios que tienen cuotas pendientes, mostrando la cuota y fecha de vencimiento y interes acumulado.
CREATE OR REPLACE VIEW SA_JS_JO_NR_CUOTAS_PENDIENTES AS
SELECT U.ID_USUARIO, U.NOMBRE, C.COD_CUOTA, C.MONTO_CUOTA, C.FECHA_VENCIMIENTO, C.INTERES_ACUMULADO
FROM SA_JS_JO_NR_USUARIOS U
JOIN SA_JS_JO_NR_CUOTAS C ON U.ID_USUARIO = C.ID_USUARIO
WHERE C.ESTADO = 'Pendiente';

--2. Reporte de Proyectos por Estado
--Este reporte muestra el estado de cada proyecto en la base de datos, organizado por estado.
CREATE OR REPLACE VIEW SA_JS_JO_NR_PROYECTOS_ESTADO AS
SELECT P.ESTADO, P.ID_PROYECTO, P.NOMBRE_PROYECTO, P.FECHA_INICIO, P.FECHA_ESTIMADA_FIN
FROM SA_JS_JO_NR_PROYECTOS P
ORDER BY P.ESTADO;

--3. Reporte de Historial de Pagos
--Este reporte muestra todos los pagos realizados para un periodo específico. Se puede adaptar para usar un parámetro de fechas para limitar el periodo.
CREATE OR REPLACE VIEW SA_JS_JO_NR_HISTORIAL_PAGOS AS
SELECT P.ID_PAGO, U.NOMBRE AS USUARIO, P.MONTO, P.FECHA_PAGO
FROM SA_JS_JO_NR_PAGOS P
JOIN SA_JS_JO_NR_USUARIOS U ON P.ID_USUARIO = U.ID_USUARIO;