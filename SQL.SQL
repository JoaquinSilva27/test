CREATE TABLE SA_JS_JO_NR_REGIONES( --MANTENEDOR LISTO
	COD_REGION NUMBER,
	NOMBRE_REGION VARCHAR2(50),
	CONSTRAINT PK_SA_JS_JO_NR_REGIONES PRIMARY KEY(COD_REGION)
);

CREATE TABLE SA_JS_JO_NR_DIRECCIONES( --MANTENEDOR LISTO
	COD_CALLEN NUMBER,
	CALLE_DIRECCION VARCHAR2(60),
	NUMERO_DIRECCION NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECCIONES PRIMARY KEY(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_COMUNAS( --MANTENEDOR LISTO
	COD_COMUNA NUMBER,
	NOMBRE_COMUNA VARCHAR2(60),
	COD_REGION NUMBER,
	COD_CALLEN NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMUNAS PRIMARY KEY(COD_COMUNA),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_DIRECCIONES FOREIGN KEY(COD_CALLEN) REFERENCES SA_JS_JO_NR_DIRECCIONES(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_TIPO_CUOTAS( --MANTENEDOR LISTO
	COD_TIPO_CUOTA NUMBER,
	TIPO_CUOTA VARCHAR2(20),
	MONTO_CUOTA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_TIPO_CUOTAS PRIMARY KEY(COD_TIPO_CUOTA)
);

CREATE TABLE SA_JS_JO_NR_SERVICIOS( --MANTENEDOR LISTO
	COD_SERVICIO NUMBER,
	NOMBRE_SERVICIO VARCHAR2(40),
	CONSTRAINT PK_SA_JS_JO_NR_SERVICIOS PRIMARY KEY(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_CUOTAS( --MANTENEDOR LISTO
	COD_CUOTA NUMBER,
	COD_TIPO_CUOTA NUMBER,
	TOTAL_CUOTA NUMBER, --REVISAR
	FECHA_VENCIMIENTO_CUOTA DATE,
	COD_SERVICIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CUOTAS PRIMARY KEY(COD_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_TIPO_CUOTAS FOREIGN KEY(COD_TIPO_CUOTA) REFERENCES SA_JS_JO_NR_TIPO_CUOTAS(COD_TIPO_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_SERVICIOS FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_USUARIOS( --MANTENEDOR LISTO
	RUT_USUARIO NUMBER,
	NOMBRE_USUARIO VARCHAR2(100),
    ROL VARCHAR2(10),
	APELLIDO1_USUARIO VARCHAR2(50),
	APELLIDO2_USUARIO VARCHAR2(50),
	COD_REGION NUMBER,
	CORREO_USUARIO VARCHAR2(100),
	TELEFONO_USUARIO NUMBER,
	COD_CUOTA NUMBER,
	--COD_PREDIO NUMBER,
    DEUDA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_USUARIOS PRIMARY KEY(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_CUOTAS FOREIGN KEY(COD_CUOTA) REFERENCES SA_JS_JO_NR_CUOTAS(COD_CUOTA)
	--CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_CUENTAS (
    NOMBRE_USUARIO VARCHAR2(12),
    PRIVILEGIOS VARCHAR2(20),
    CONTRASEÑA VARCHAR2(20),
    CONSTRAINT PK_SA_JS_JO_NR_CUENTAS PRIMARY KEY(NOMBRE_USUARIO)
);


CREATE TABLE SA_JS_JO_NR_PREDIOS( --MANTENEDOR LISTO
	COD_PREDIO NUMBER, 
	ROL_PREDIO NUMBER,
	HECTAREAS_PREDIO NUMBER,
	ACCIONES_PREDIO NUMBER,
    RUT_USUARIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PREDIOS PRIMARY KEY(COD_PREDIO),
    CONSTRAINT FK_SA_JS_JO_NR_PREDIOS_USUARIOS FOREIGN KEY(RUT_USUARIO) REFERENCES SA_JS_JO_NR_USUARIOS(RUT_USUARIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_PAGOS(
	COD_HISTORIAL_PAGO NUMBER,
	NOMBRE_PAGADOR VARCHAR2(100),
	DETALLE_PAGO VARCHAR2(200),
	FECHA_PAGO DATE,
    PAGO NUMBER,
	RUT_USUARIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_PAGOS PRIMARY KEY(COD_HISTORIAL_PAGO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_PAGOS_USUARIOS FOREIGN KEY(RUT_USUARIO) REFERENCES SA_JS_JO_NR_USUARIOS(RUT_USUARIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_CAMBIOS(
	COD_HISTORIAL_CAMBIO NUMBER,
	DETALLE_CAMBIO VARCHAR2(200),
	FECHA_CAMBIO DATE,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_CAMBIOS PRIMARY KEY(COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_CAMBIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)	
);

CREATE TABLE SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS(
	RUT_USUARIO NUMBER,
	COD_HISTORIAL_CAMBIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS PRIMARY KEY(RUT_USUARIO, COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS_USUARIOS FOREIGN KEY(RUT_USUARIO) REFERENCES SA_JS_JO_NR_USUARIOS(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS_HISTORIAL_CAMBIOS FOREIGN KEY(COD_HISTORIAL_CAMBIO) REFERENCES SA_JS_JO_NR_HISTORIAL_CAMBIOS(COD_HISTORIAL_CAMBIO)
);

CREATE TABLE SA_JS_JO_NR_SUBZONAS( --MANTENEDOR LISTO
	COD_SUBZONA NUMBER,
	NOMBRE_SUBZONA VARCHAR2(150),
	CONSTRAINT PK_SA_JS_JO_NR_SUBZONAS PRIMARY KEY(COD_SUBZONA)
);

CREATE TABLE SA_JS_JO_NR_ZONAS( --MANTENEDOR LISTO
	COD_ZONA NUMBER,
	NOMBRE_ZONA VARCHAR2(150),
	COD_SUBZONA NUMBER,
	COD_COMUNA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_ZONAS PRIMARY KEY(COD_ZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_SUBZONAS FOREIGN KEY(COD_SUBZONA) REFERENCES SA_JS_JO_NR_SUBZONAS(COD_SUBZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_COMUNAS FOREIGN KEY(COD_COMUNA) REFERENCES SA_JS_JO_NR_COMUNAS(COD_COMUNA)
);

CREATE TABLE SA_JS_JO_NR_SECTORES( --MANTENEDOR LISTO
	COD_SECTOR NUMBER, 
	NOMBRE_SECTOR VARCHAR2(100),
	COD_ZONA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_SECTORES PRIMARY KEY(COD_SECTOR),
	CONSTRAINT FK_SA_JS_JO_NR_SECTORES_ZONAS FOREIGN KEY(COD_ZONA) REFERENCES SA_JS_JO_NR_ZONAS(COD_ZONA)
);

CREATE TABLE SA_JS_JO_NR_CANALES( --MANTENEDOR LISTO
	COD_CANAL NUMBER,
	NOMBRE_CANAL VARCHAR2(100),
	FACTOR_CANAL NUMBER,
	COD_SECTOR NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CANALES PRIMARY KEY(COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_CANALES_SECTORES FOREIGN KEY(COD_SECTOR) REFERENCES SA_JS_JO_NR_SECTORES(COD_SECTOR)
);

CREATE TABLE SA_JS_JO_NR_DIRECTIVAS( --MANTENEDOR LISTO
	COD_DIRECTIVA NUMBER,
	NOMBRE_DIRECTIVA VARCHAR2(100),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECTIVAS PRIMARY KEY(COD_DIRECTIVA),
	CONSTRAINT FK_SA_JS_JO_NR_DIRECTIVAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PRESIDENTES( --MANTENEDOR LISTO
	COD_PRESIDENTE NUMBER,
	NOMBRE_PRESIDENTE VARCHAR2(100),
	APELLIDO1_PRESIDENTE VARCHAR2(50),
	APELLIDO2_PRESIDENTE VARCHAR2(50),
	COD_DIRECTIVA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PRESIDENTES PRIMARY KEY(COD_PRESIDENTE),
	CONSTRAINT FK_SA_JS_JO_NR_PRESIDENTES_DIRECTIVAS FOREIGN KEY(COD_DIRECTIVA) REFERENCES SA_JS_JO_NR_DIRECTIVAS(COD_DIRECTIVA)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_SERVICIO_CANALES(
	COD_SERVICIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES PRIMARY KEY(COD_SERVICIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES_SERVICIOS FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANALES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_PREDIO_CANALES(
	COD_PREDIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES PRIMARY KEY(COD_PREDIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANALES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PROYECTOS( --MANTENEDOR LISTO
	COD_PROYECTO NUMBER,
	NOMBRE_PROYECTO VARCHAR2(100),
	DESCRIPCION_PROYECTO VARCHAR2(200),
	FECHA_INICIO_PROYECTO DATE,
	FECHA_FIN_PROYECTO DATE,
	ESTADO_PROYECTO VARCHAR2(20),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PROYECTOS PRIMARY KEY(COD_PROYECTO),
	CONSTRAINT FK_SA_JS_JO_NR_PROYECTOS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_COMPUERTAS( --MANTENEDOR LISTO
	COD_COMPUERTA NUMBER,
	KILOMETRAJE_COMPUERTA NUMBER,
	DESCRIPCION_COMPUERTA VARCHAR2(200),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMPUERTAS PRIMARY KEY(COD_COMPUERTA),
	CONSTRAINT FK_SA_JS_JO_NR_COMPUERTAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_CELADORES( --MANTENEDOR LISTO
	COD_CELADOR NUMBER,
	NOMBRE_CELADOR VARCHAR2(100),
	APELLIDO1_CELADOR VARCHAR2(50),
	APELLIDO2_CELADOR VARCHAR2(50),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CELADORES PRIMARY KEY(COD_CELADOR),
	CONSTRAINT FK_SA_JS_JO_NR_CELADORES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

-- triggers initcap

CREATE OR REPLACE TRIGGER INITCAP_REGIONES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_REGIONES
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_REGION := INITCAP(:NEW.NOMBRE_REGION);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_DIRECCIONES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_DIRECCIONES
FOR EACH ROW
BEGIN
    :NEW.CALLE_DIRECCION := INITCAP(:NEW.CALLE_DIRECCION);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_COMUNAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_COMUNAS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_COMUNA := INITCAP(:NEW.NOMBRE_COMUNA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_TIPO_CUOTAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_TIPO_CUOTAS
FOR EACH ROW
BEGIN
    :NEW.TIPO_CUOTA := INITCAP(:NEW.TIPO_CUOTA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_SERVICIOS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_SERVICIOS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_SERVICIO := INITCAP(:NEW.NOMBRE_SERVICIO);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_USUARIOS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_USUARIOS
FOR EACH ROW
BEGIN
    :NEW.ROL := INITCAP(:NEW.ROL);
    :NEW.NOMBRE_USUARIO := INITCAP(:NEW.NOMBRE_USUARIO);
    :NEW.APELLIDO1_USUARIO := INITCAP(:NEW.APELLIDO1_USUARIO);
    :NEW.APELLIDO2_USUARIO := INITCAP(:NEW.APELLIDO2_USUARIO);
    :NEW.CORREO_USUARIO := LOWER(:NEW.CORREO_USUARIO);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_HISTORIAL_PAGOS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_HISTORIAL_PAGOS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_PAGADOR := INITCAP(:NEW.NOMBRE_PAGADOR);
    :NEW.DETALLE_PAGO := LOWER(:NEW.DETALLE_PAGO);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_HISTORIAL_CAMBIOS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_HISTORIAL_CAMBIOS
FOR EACH ROW
BEGIN
    :NEW.DETALLE_CAMBIO := LOWER(:NEW.DETALLE_CAMBIO);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_SUBZONAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_SUBZONAS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_SUBZONA := INITCAP(:NEW.NOMBRE_SUBZONA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_ZONAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_ZONAS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_ZONA := INITCAP(:NEW.NOMBRE_ZONA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_SECTORES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_SECTORES
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_SECTOR := INITCAP(:NEW.NOMBRE_SECTOR);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_CANALES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_CANALES
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_CANAL := INITCAP(:NEW.NOMBRE_CANAL);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_DIRECTIVAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_DIRECTIVAS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_DIRECTIVA := INITCAP(:NEW.NOMBRE_DIRECTIVA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_PRESIDENTES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_PRESIDENTES
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_PRESIDENTE := INITCAP(:NEW.NOMBRE_PRESIDENTE);
    :NEW.APELLIDO1_PRESIDENTE := INITCAP(:NEW.APELLIDO1_PRESIDENTE);
    :NEW.APELLIDO2_PRESIDENTE := INITCAP(:NEW.APELLIDO2_PRESIDENTE);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_PROYECTOS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_PROYECTOS
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_PROYECTO := INITCAP(:NEW.NOMBRE_PROYECTO);
    :NEW.DESCRIPCION_PROYECTO := LOWER(:NEW.DESCRIPCION_PROYECTO);
    :NEW.ESTADO_PROYECTO := INITCAP(:NEW.ESTADO_PROYECTO);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_COMPUERTAS
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_COMPUERTAS
FOR EACH ROW
BEGIN
    :NEW.DESCRIPCION_COMPUERTA := LOWER(:NEW.DESCRIPCION_COMPUERTA);
END;
/

CREATE OR REPLACE TRIGGER INITCAP_CELADORES
BEFORE INSERT OR UPDATE
ON SA_JS_JO_NR_CELADORES
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_CELADOR := INITCAP(:NEW.NOMBRE_CELADOR);
    :NEW.APELLIDO1_CELADOR := INITCAP(:NEW.APELLIDO1_CELADOR);
    :NEW.APELLIDO2_CELADOR := INITCAP(:NEW.APELLIDO2_CELADOR);

END;
/

-- Triggers
--función: genera contraseña para luego agregar la información a la tabla cuentas
CREATE OR REPLACE TRIGGER SA_JS_JO_NR_TRG_CREAR_CUENTA
AFTER INSERT ON SA_JS_JO_NR_USUARIOS
FOR EACH ROW
DECLARE
    CONTRASENA_GENERADA VARCHAR2(20);
BEGIN
    -- Generar la contraseña con los primeros 4 dígitos del RUT del usuario
    CONTRASENA_GENERADA := SUBSTR(:NEW.RUT_USUARIO, 1, 4);
    
    -- Insertar en la tabla cuentas los datos correspondientes
    INSERT INTO SA_JS_JO_NR_CUENTAS (
        NOMBRE_USUARIO,
        PRIVILEGIOS,
        CONTRASEÑA
    ) VALUES (
        :NEW.RUT_USUARIO,
        :NEW.ROL,
        CONTRASENA_GENERADA
    );
END;
/



-- función: verifica que existan los codigos de region y de calle asociados a la comuna que se inserte o actualice en las tablas de regiones y direcciones
CREATE OR REPLACE TRIGGER SA_JS_JO_NR_trg_verifica_integridad_comunas
BEFORE INSERT OR UPDATE ON SA_JS_JO_NR_COMUNAS
FOR EACH ROW
DECLARE
    v_region_exists NUMBER;
    v_direccion_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_region_exists
    FROM SA_JS_JO_NR_REGIONES
    WHERE COD_REGION = :NEW.COD_REGION;

    IF v_region_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'La región no existe :,v.');
    END IF;

    SELECT COUNT(*) INTO v_direccion_exists
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = :NEW.COD_CALLEN;

    IF v_direccion_exists = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'La dirección no existe papu :c.');
    END IF;
END;
/

-- funcion: verifica que no haya ninguna comuna asociada a la region que se desea eliminar, si existe entonces no se elimna
CREATE OR REPLACE TRIGGER SA_JS_JO_NR_trg_prevenir_eliminacion_region
BEFORE DELETE ON SA_JS_JO_NR_REGIONES
FOR EACH ROW
DECLARE
    v_comuna_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_comuna_exists
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_REGION = :OLD.COD_REGION;

    IF v_comuna_exists > 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'No se puede eliminar la región porque tiene comunas dentro de ella. Borra la/s comunas primero');
    END IF;
END;
/

-- MANTENEDORES

-- REGIONES
CREATE OR REPLACE PROCEDURE AGREGAR_REGIONES(
    P_NOMBRE_REGION VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_REGION),0)+1 INTO PK
    FROM SA_JS_JO_NR_REGIONES;
 
	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_REGIONES (COD_REGION, NOMBRE_REGION)
    VALUES (PK, P_NOMBRE_REGION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501,'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010,'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_REGIONES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_REGIONES
        WHERE COD_REGION = P_PK;
END LEER_REGIONES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_REGIONES(
    P_COD_REGION NUMBER,
    P_NOMBRE_REGION VARCHAR2
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

	IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Región no encontrada');
    
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	UPDATE SA_JS_JO_NR_REGIONES
    	SET NOMBRE_REGION = P_NOMBRE_REGION
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_REGIONES(
    P_COD_REGION NUMBER
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

    IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Región no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	DELETE FROM SA_JS_JO_NR_REGIONES
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
	WHEN OTHERS THEN
        ROLLBACK;
    	RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

--DIRECCIONES
CREATE OR REPLACE PROCEDURE AGREGAR_DIRECCIONES(
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CALLEN),0)+1 INTO PK
    FROM SA_JS_JO_NR_DIRECCIONES;

	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_DIRECCIONES (COD_CALLEN, CALLE_DIRECCION, NUMERO_DIRECCION)
    VALUES (PK, P_CALLE_DIRECCION, P_NUMERO_DIRECCION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECCIONES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_DIRECCIONES
        WHERE COD_CALLEN = P_PK;
END LEER_DIRECCIONES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECCIONES(
    P_COD_CALLEN NUMBER,
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        UPDATE SA_JS_JO_NR_DIRECCIONES
        SET CALLE_DIRECCION = P_CALLE_DIRECCION,
            NUMERO_DIRECCION = P_NUMERO_DIRECCION
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECCIONES(
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        DELETE FROM SA_JS_JO_NR_DIRECCIONES
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

-- COMUNAS 
CREATE OR REPLACE PROCEDURE AGREGAR_COMUNAS(
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_COMUNA),0)+1 INTO PK
    FROM SA_JS_JO_NR_COMUNAS;

	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_COMUNAS (COD_COMUNA, NOMBRE_COMUNA, COD_REGION, COD_CALLEN)
    VALUES (PK, P_NOMBRE_COMUNA, P_COD_REGION, P_COD_CALLEN);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la comuna');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMUNAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_COMUNAS
        WHERE COD_COMUNA = P_PK;
END LEER_COMUNAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMUNAS(
    P_COD_COMUNA NUMBER,
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_COMUNAS
        SET NOMBRE_COMUNA = P_NOMBRE_COMUNA,
            COD_REGION = P_COD_REGION,
            COD_CALLEN = P_COD_CALLEN
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la comuna');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMUNAS(
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_COMUNAS
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la comuna');
END;
/

-- TIPO CUOTAS
CREATE OR REPLACE PROCEDURE AGREGAR_TIPO_CUOTAS(
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_TIPO_CUOTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_TIPO_CUOTAS;

	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_TIPO_CUOTAS (COD_TIPO_CUOTA, TIPO_CUOTA, MONTO_CUOTA)
    VALUES (PK, P_TIPO_CUOTA, P_MONTO_CUOTA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_TIPO_CUOTAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_TIPO_CUOTAS
        WHERE COD_TIPO_CUOTA = P_PK;
END LEER_TIPO_CUOTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_TIPO_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER,
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTAS
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_TIPO_CUOTAS
        SET TIPO_CUOTA = P_TIPO_CUOTA,
            MONTO_CUOTA = P_MONTO_CUOTA
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_TIPO_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTAS
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_TIPO_CUOTAS
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del tipo de cuota');
END;
/

-- SERVICIOS
CREATE OR REPLACE PROCEDURE AGREGAR_SERVICIOS(
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SERVICIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_SERVICIOS;

	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_SERVICIOS (COD_SERVICIO, NOMBRE_SERVICIO)
    VALUES (PK, P_NOMBRE_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el servicio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SERVICIOS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_SERVICIOS
        WHERE COD_SERVICIO = P_PK;
END LEER_SERVICIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SERVICIOS(
    P_COD_SERVICIO NUMBER,
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_SERVICIOS
        SET NOMBRE_SERVICIO = P_NOMBRE_SERVICIO
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del servicio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SERVICIOS(
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_SERVICIOS
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del servicio');
END;
/

-- CUOTAS
CREATE OR REPLACE PROCEDURE AGREGAR_CUOTAS(
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CUOTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_CUOTAS;

	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_CUOTAS (COD_CUOTA, COD_TIPO_CUOTA, TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA, COD_SERVICIO)
    VALUES (PK, P_COD_TIPO_CUOTA, P_TOTAL_CUOTA, P_FECHA_VENCIMIENTO_CUOTA, P_COD_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CUOTAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_CUOTAS
        WHERE COD_CUOTA = P_PK;
END LEER_CUOTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CUOTAS(
    P_COD_CUOTA NUMBER,
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_CUOTAS
        SET COD_TIPO_CUOTA = P_COD_TIPO_CUOTA,
            TOTAL_CUOTA = P_TOTAL_CUOTA,
            FECHA_VENCIMIENTO_CUOTA = P_FECHA_VENCIMIENTO_CUOTA,
            COD_SERVICIO = P_COD_SERVICIO
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CUOTAS(
    P_COD_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_CUOTAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_CUOTAS
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la cuota');
END;
/

--PREDIOS
CREATE OR REPLACE PROCEDURE AGREGAR_PREDIOS(
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER,
    P_RUT_USUARIO NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PREDIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_PREDIOS;

	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_PREDIOS (COD_PREDIO, ROL_PREDIO, HECTAREAS_PREDIO, ACCIONES_PREDIO, RUT_USUARIO)
    VALUES (PK, P_ROL_PREDIO, P_HECTAREAS_PREDIO, P_ACCIONES_PREDIO, P_RUT_USUARIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el predio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PREDIOS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_PREDIOS
        WHERE COD_PREDIO = P_PK;
END LEER_PREDIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PREDIOS(
    P_COD_PREDIO NUMBER,
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER,
    P_RUT_USUARIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_PREDIOS
        SET ROL_PREDIO = P_ROL_PREDIO,
            HECTAREAS_PREDIO = P_HECTAREAS_PREDIO,
            ACCIONES_PREDIO = P_ACCIONES_PREDIO,
            RUT_USUARIO = P_RUT_USUARIO
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del predio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PREDIOS(
    P_COD_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_PREDIOS
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del predio');
END;
/

-- USUARIOS
CREATE OR REPLACE PROCEDURE AGREGAR_USUARIOS(
    P_RUT_USUARIO NUMBER,
    P_NOMBRE_USUARIO VARCHAR2,
    P_ROL VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_DEUDA NUMBER
) 
IS
    --DECLARE PK NUMBER := 0;
BEGIN
    /*SELECT NVL(MAX(RUT_USUARIO),0)+1 INTO PK
    FROM SA_JS_JO_NR_USUARIO;
    -- Bloqueo de la tabla para control de concurrencia
    
*/
    LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_USUARIOS (
        RUT_USUARIO, NOMBRE_USUARIO, ROL, APELLIDO1_USUARIO, APELLIDO2_USUARIO,
        COD_REGION, CORREO_USUARIO, TELEFONO_USUARIO, COD_CUOTA, DEUDA
    )
    VALUES (
        P_RUT_USUARIO, P_NOMBRE_USUARIO, P_ROL, P_APELLIDO1_USUARIO, 
        P_APELLIDO2_USUARIO, P_COD_REGION, P_CORREO_USUARIO, P_TELEFONO_USUARIO, 
        P_COD_CUOTA, P_DEUDA
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el usuario');
END;
/

CREATE OR REPLACE PROCEDURE LEER_USUARIOS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_USUARIOS
        WHERE RUT_USUARIO = P_PK;
END LEER_USUARIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_USUARIOS(
    P_RUT_USUARIO NUMBER,
    P_NOMBRE_USUARIO VARCHAR2,
    P_ROL VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_DEUDA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIOS
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_USUARIOS
        SET NOMBRE_USUARIO = P_NOMBRE_USUARIO,
            ROL = P_ROL,
            APELLIDO1_USUARIO = P_APELLIDO1_USUARIO,
            APELLIDO2_USUARIO = P_APELLIDO2_USUARIO,
            COD_REGION = P_COD_REGION,
            CORREO_USUARIO = P_CORREO_USUARIO,
            TELEFONO_USUARIO = P_TELEFONO_USUARIO,
            COD_CUOTA = P_COD_CUOTA,
            DEUDA = P_DEUDA
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del usuario');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_USUARIOS(
    P_RUT_USUARIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIOS
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIOS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_USUARIOS
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del usuario');
END;
/

-- SUBZONAS
CREATE OR REPLACE PROCEDURE AGREGAR_SUBZONAS(
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SUBZONA),0)+1 INTO PK
    FROM SA_JS_JO_NR_SUBZONAS;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SUBZONAS (COD_SUBZONA, NOMBRE_SUBZONA)
    VALUES (PK, P_NOMBRE_SUBZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la subzona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SUBZONAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_SUBZONAS
        WHERE COD_SUBZONA = P_PK;
END LEER_SUBZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SUBZONAS(
    P_COD_SUBZONA NUMBER,
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SUBZONAS
        SET NOMBRE_SUBZONA = P_NOMBRE_SUBZONA
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la subzona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SUBZONAS(
    P_COD_SUBZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SUBZONAS
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la subzona');
END;
/

-- ZONAS
CREATE OR REPLACE PROCEDURE AGREGAR_ZONAS(
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_ZONA),0)+1 INTO PK
    FROM SA_JS_JO_NR_ZONAS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_ZONAS (COD_ZONA, NOMBRE_ZONA, COD_SUBZONA, COD_COMUNA)
    VALUES (PK, P_NOMBRE_ZONA, P_COD_SUBZONA, P_COD_COMUNA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la zona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_ZONAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_ZONAS
        WHERE COD_ZONA = P_PK;
END LEER_ZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_ZONAS(
    P_COD_ZONA NUMBER,
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_ZONAS
        SET NOMBRE_ZONA = P_NOMBRE_ZONA,
            COD_SUBZONA = P_COD_SUBZONA,
            COD_COMUNA = P_COD_COMUNA
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la zona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_ZONAS(
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_ZONAS
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la zona');
END;
/

-- SECTORES
CREATE OR REPLACE PROCEDURE AGREGAR_SECTORES(
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_SECTOR),0)+1 INTO PK
    FROM SA_JS_JO_NR_SECTORES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SECTORES (COD_SECTOR, NOMBRE_SECTOR, COD_ZONA)
    VALUES (PK, P_NOMBRE_SECTOR, P_COD_ZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el sector');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SECTORES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_SECTORES
        WHERE COD_SECTOR = P_PK;
END LEER_SECTORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SECTORES(
    P_COD_SECTOR NUMBER,
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SECTORES
        SET NOMBRE_SECTOR = P_NOMBRE_SECTOR,
            COD_ZONA = P_COD_ZONA
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del sector');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SECTORES(
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SECTORES
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del sector');
END;
/

-- CANALES
CREATE OR REPLACE PROCEDURE AGREGAR_CANALES(
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CANAL),0)+1 INTO PK
    FROM SA_JS_JO_NR_CANALES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CANALES (COD_CANAL, NOMBRE_CANAL, FACTOR_CANAL, COD_SECTOR)
    VALUES (PK, P_NOMBRE_CANAL, P_FACTOR_CANAL, P_COD_SECTOR);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el canal');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CANALES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_CANALES
        WHERE COD_CANAL = P_PK;
END LEER_CANALES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CANALES(
    P_COD_CANAL NUMBER,
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CANALES
        SET NOMBRE_CANAL = P_NOMBRE_CANAL,
            FACTOR_CANAL = P_FACTOR_CANAL,
            COD_SECTOR = P_COD_SECTOR
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del canal');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CANALES(
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CANALES
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del canal');
END;
/

-- DIRECTIVAS
CREATE OR REPLACE PROCEDURE AGREGAR_DIRECTIVAS(
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_DIRECTIVA),0)+1 INTO PK
    FROM SA_JS_JO_NR_DIRECTIVAS;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_DIRECTIVAS (COD_DIRECTIVA, NOMBRE_DIRECTIVA, COD_CANAL)
    VALUES (PK, P_NOMBRE_DIRECTIVA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la directiva');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECTIVAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_DIRECTIVAS
        WHERE COD_DIRECTIVA = P_PK;
END LEER_DIRECTIVAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECTIVAS(
    P_COD_DIRECTIVA NUMBER,
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_DIRECTIVAS
        SET NOMBRE_DIRECTIVA = P_NOMBRE_DIRECTIVA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la directiva');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECTIVAS(
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_DIRECTIVAS
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la directiva');
END;
/

-- PRESIDENTES
CREATE OR REPLACE PROCEDURE AGREGAR_PRESIDENTES(
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PRESIDENTE),0)+1 INTO PK
    FROM SA_JS_JO_NR_PRESIDENTES;

    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PRESIDENTES (COD_PRESIDENTE, NOMBRE_PRESIDENTE, APELLIDO1_PRESIDENTE, APELLIDO2_PRESIDENTE, COD_DIRECTIVA)
    VALUES (PK, P_NOMBRE_PRESIDENTE, P_APELLIDO1_PRESIDENTE, P_APELLIDO2_PRESIDENTE, P_COD_DIRECTIVA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el presidente');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PRESIDENTES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_PRESIDENTES
        WHERE COD_PRESIDENTE = P_PK;
END LEER_PRESIDENTES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PRESIDENTES(
    P_COD_PRESIDENTE NUMBER,
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PRESIDENTES
        SET NOMBRE_PRESIDENTE = P_NOMBRE_PRESIDENTE,
            APELLIDO1_PRESIDENTE = P_APELLIDO1_PRESIDENTE,
            APELLIDO2_PRESIDENTE = P_APELLIDO2_PRESIDENTE,
            COD_DIRECTIVA = P_COD_DIRECTIVA
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del presidente');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PRESIDENTES(
    P_COD_PRESIDENTE NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PRESIDENTES
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del presidente');
END;
/

-- PROYECTOS
CREATE OR REPLACE PROCEDURE AGREGAR_PROYECTOS(
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_PROYECTO),0)+1 INTO PK
    FROM SA_JS_JO_NR_PROYECTOS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PROYECTOS (
        COD_PROYECTO, NOMBRE_PROYECTO, DESCRIPCION_PROYECTO, 
        FECHA_INICIO_PROYECTO, FECHA_FIN_PROYECTO, ESTADO_PROYECTO, COD_CANAL
    )
    VALUES (
        PK, P_NOMBRE_PROYECTO, P_DESCRIPCION_PROYECTO, 
        P_FECHA_INICIO_PROYECTO, P_FECHA_FIN_PROYECTO, P_ESTADO_PROYECTO, P_COD_CANAL
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el proyecto');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PROYECTOS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_PROYECTOS
        WHERE COD_PROYECTO = P_PK;
END LEER_PROYECTOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PROYECTOS(
    P_COD_PROYECTO NUMBER,
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PROYECTOS
        SET NOMBRE_PROYECTO = P_NOMBRE_PROYECTO,
            DESCRIPCION_PROYECTO = P_DESCRIPCION_PROYECTO,
            FECHA_INICIO_PROYECTO = P_FECHA_INICIO_PROYECTO,
            FECHA_FIN_PROYECTO = P_FECHA_FIN_PROYECTO,
            ESTADO_PROYECTO = P_ESTADO_PROYECTO,
            COD_CANAL = P_COD_CANAL
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del proyecto');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PROYECTOS(
    P_COD_PROYECTO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PROYECTOS
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del proyecto');
END;
/

-- COMPUERTAS
CREATE OR REPLACE PROCEDURE AGREGAR_COMPUERTAS(
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_COMPUERTA),0)+1 INTO PK
    FROM SA_JS_JO_NR_COMPUERTAS;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_COMPUERTAS (COD_COMPUERTA, KILOMETRAJE_COMPUERTA, DESCRIPCION_COMPUERTA, COD_CANAL)
    VALUES (PK, P_KILOMETRAJE_COMPUERTA, P_DESCRIPCION_COMPUERTA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMPUERTAS(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_COMPUERTAS
        WHERE COD_COMPUERTA = P_PK;
END LEER_COMPUERTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMPUERTAS(
    P_COD_COMPUERTA NUMBER,
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_COMPUERTAS
        SET KILOMETRAJE_COMPUERTA = P_KILOMETRAJE_COMPUERTA,
            DESCRIPCION_COMPUERTA = P_DESCRIPCION_COMPUERTA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMPUERTAS(
    P_COD_COMPUERTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_COMPUERTAS
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la compuerta');
END;
/

-- CELADORES
CREATE OR REPLACE PROCEDURE AGREGAR_CELADORES(
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    PK NUMBER := 0;
BEGIN
    SELECT NVL(MAX(COD_CELADOR),0)+1 INTO PK
    FROM SA_JS_JO_NR_CELADORES;
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CELADORES (COD_CELADOR, NOMBRE_CELADOR, APELLIDO1_CELADOR, APELLIDO2_CELADOR, COD_CANAL)
    VALUES (PK, P_NOMBRE_CELADOR, P_APELLIDO1_CELADOR, P_APELLIDO2_CELADOR, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el celador');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CELADORES(
    P_PK IN NUMBER,
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR
        SELECT *
        FROM SA_JS_JO_NR_CELADORES
        WHERE COD_CELADOR = P_PK;
END LEER_CELADORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CELADORES(
    P_COD_CELADOR NUMBER,
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CELADORES
        SET NOMBRE_CELADOR = P_NOMBRE_CELADOR,
            APELLIDO1_CELADOR = P_APELLIDO1_CELADOR,
            APELLIDO2_CELADOR = P_APELLIDO2_CELADOR,
            COD_CANAL = P_COD_CANAL
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del celador');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CELADORES(
    P_COD_CELADOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CELADORES
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del celador');
END;
/

-- Funciones

-- Funcion para calcular interes
CREATE OR REPLACE FUNCTION calcular_total_con_interes(
    p_cod_cuota NUMBER
) RETURN NUMBER IS
    v_total_con_interes NUMBER := 0;
    v_dias_vencidos NUMBER := 0;
    v_total_cuota NUMBER;
    v_fecha_vencimiento DATE;
BEGIN
    SELECT TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA 
    INTO v_total_cuota, v_fecha_vencimiento
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = p_cod_cuota;

    IF v_fecha_vencimiento < SYSDATE THEN
        v_dias_vencidos := SYSDATE - v_fecha_vencimiento;
    END IF;
    -- Calcular el total con interés (0.05% por día de atraso) (cambiar)
    v_total_con_interes := v_total_cuota + (v_total_cuota * 0.00053 * v_dias_vencidos);
    RETURN v_total_con_interes;
END;
/
-- EJEMPLO DE USO:
SELECT COD_CUOTA,
       TOTAL_CUOTA,
       calcular_total_con_interes(COD_CUOTA) AS TOTAL_CON_INTERES
FROM SA_JS_JO_NR_CUOTAS
WHERE COD_CUOTA = 101;  -- Reemplaza 101 con el código de la cuota que deseas consultar


-- fUNCION PARA VERIFICAR DISPONIBILIDAD DEL PROYECTO (No sé quien la hizo pero como me daba error la cambié)
/*CREATE OR REPLACE FUNCTION verificar_disponibilidad_proyecto(
    p_cod_proyecto NUMBER
) RETURN BOOLEAN IS
    v_disponible BOOLEAN := TRUE;
    v_estado VARCHAR2(20);
    v_cuotas_vencidas NUMBER;
BEGIN
    -- Verificar si el proyecto está activo
    SELECT estado INTO v_estado
    FROM SA_JS_JO_NR_PROYECTOS  -- Suponiendo que existe una tabla de proyectos
    WHERE cod_proyecto = p_cod_proyecto;

    IF v_estado != 'Activo' THEN
        v_disponible := FALSE;
    END IF;
    RETURN v_disponible;
    verificar_disponibilidad_proyecto;
END;
*/
CREATE OR REPLACE FUNCTION verificar_disponibilidad_proyecto(
    p_cod_proyecto NUMBER
) RETURN BOOLEAN IS
    v_disponible BOOLEAN := TRUE;
    v_estado VARCHAR2(20);
BEGIN
    -- Verificar si el proyecto está activo
    BEGIN
        SELECT ESTADO_PROYECTO INTO v_estado
        FROM SA_JS_JO_NR_PROYECTOS  -- Asegúrate de que la columna 'ESTADO_PROYECTO' existe en esta tabla
        WHERE COD_PROYECTO = p_cod_proyecto;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Si no se encuentra el proyecto, devolvemos falso
            RETURN FALSE;
    END;

    IF v_estado != 'Activo' THEN
        v_disponible := FALSE;
    END IF;

    RETURN v_disponible;
END;

/* GESTORES
1. Gestor de Cuotas Pendientes por Usuario
Este gestor calcula el total de cuotas pendientes por usuario. Puede ser útil para monitorear qué usuarios tienen pagos atrasados.
2. Gestor de Proyectos Activos por Canal
Este gestor obtiene la lista de proyectos activos (es decir, proyectos en curso) por cada canal.
3. Gestor de Historial de Pagos por Predio
Este gestor devuelve un historial de pagos para cada predio, útil para ver el historial de contribuciones de cada uno.
4. Gestor de Servicios por Canal
Este gestor muestra todos los servicios asociados a cada canal, mostrando su relación en detalle.
5. Gestor de Celadores por Canal
Este gestor muestra la lista de celadores asignados a cada canal, lo cual es útil para analizar la distribución de personal.*/

/* ideas gestores
-automatizacion para las tablas detalle_historial_usuario, historial_cambios, historial_pagos, detalle_servicio_canal y detalle_predio_canal
-calcular valor cuota en base al factor
*/
--calcular total cuota

CREATE OR REPLACE TRIGGER trg_modificar_total_cuota -- BIEN
before INSERT OR UPDATE ON SA_JS_JO_NR_CUOTAS
FOR EACH ROW
DECLARE
    v_monto_cuota NUMBER;
    v_tipo_cuota VARCHAR2(20);
    v_total_cuota NUMBER;
BEGIN
    -- Obtener el tipo_cuota y monto_cuota de la tabla SA_JS_JO_NR_TIPO_CUOTAS
    SELECT MONTO_CUOTA, TIPO_CUOTA
    INTO v_monto_cuota, v_tipo_cuota
    FROM SA_JS_JO_NR_TIPO_CUOTAS
    WHERE COD_TIPO_CUOTA = :NEW.COD_TIPO_CUOTA;

    -- Calcular el valor del total_cuota basado en el tipo_cuota
    IF v_tipo_cuota = 'Ordinaria' THEN
        v_total_cuota := v_monto_cuota * 1;
    ELSIF v_tipo_cuota = 'Extra Ordinaria' THEN
        v_total_cuota := v_monto_cuota * 1.5;
    ELSE
        -- Manejo de otros casos si aplica, asignar valor predeterminado
        v_total_cuota := 0;
    END IF;

    :NEW.TOTAL_CUOTA := v_total_cuota;
END trg_modificar_total_cuota;
/

--historial cambios predio bien
CREATE SEQUENCE SEQ_HISTORIAL_CAMBIOS
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 1000
    CACHE 50
    NOCYCLE;

CREATE OR REPLACE TRIGGER trg_historial_cambios
AFTER UPDATE ON SA_JS_JO_NR_PREDIOS
FOR EACH ROW
DECLARE
    v_cod_historial_cambio NUMBER;
BEGIN
    -- Obtener el siguiente valor de la secuencia
    SELECT SEQ_HISTORIAL_CAMBIOS.NEXTVAL INTO v_cod_historial_cambio FROM DUAL;

    -- Determinar el detalle del cambio
    IF :OLD.ROL_PREDIO = :NEW.ROL_PREDIO AND
       :OLD.HECTAREAS_PREDIO = :NEW.HECTAREAS_PREDIO AND
       :OLD.ACCIONES_PREDIO = :NEW.ACCIONES_PREDIO THEN
        -- No hubo cambios significativos en los parámetros del predio
        INSERT INTO SA_JS_JO_NR_HISTORIAL_CAMBIOS (
            COD_HISTORIAL_CAMBIO, DETALLE_CAMBIO, FECHA_CAMBIO, COD_PREDIO
        ) VALUES (
            v_cod_historial_cambio, 'Vinculación con un canal', SYSDATE, :NEW.COD_PREDIO
        );
    ELSE
        -- Hubo cambios en los parámetros del predio, registrar los cambios
        INSERT INTO SA_JS_JO_NR_HISTORIAL_CAMBIOS (
            COD_HISTORIAL_CAMBIO, DETALLE_CAMBIO, FECHA_CAMBIO, COD_PREDIO
        ) VALUES (
            v_cod_historial_cambio,
            'Cambio en predio: ROL_PREDIO (' || :OLD.ROL_PREDIO || ' -> ' || :NEW.ROL_PREDIO || '), ' ||
            'HECTAREAS_PREDIO (' || :OLD.HECTAREAS_PREDIO || ' -> ' || :NEW.HECTAREAS_PREDIO || '), ' ||
            'ACCIONES_PREDIO (' || :OLD.ACCIONES_PREDIO || ' -> ' || :NEW.ACCIONES_PREDIO || ')',
            SYSDATE, :NEW.COD_PREDIO
        );
    END IF;

    -- Registrar en detalle_historial_usuarios
    INSERT INTO SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIOS (
        RUT_USUARIO, COD_HISTORIAL_CAMBIO
    ) VALUES (
        :NEW.RUT_USUARIO, v_cod_historial_cambio
    );
END;
/
--

CREATE OR REPLACE PROCEDURE VINCULAR_PREDIO_CANALES( -- PROCEDIMIENTO va en seccion de gestores de la pagina
    P_OPCION NUMBER,
    p_cod_predio number,
    p_cod_canal number
)
IS
    v_hectarea number;
    v_accione number;
BEGIN

    IF P_OPCION = 1 THEN
        select hectareas_predio into v_hectarea 
        from SA_JS_JO_NR_predios
        where cod_predio = p_cod_predio;
        
        INSERT INTO SA_JS_JO_NR_DETALLE_PREDIO_CANALES(COD_PREDIO,COD_CANAL)
        VALUES(p_cod_predio, p_cod_canal);
        
        update SA_JS_JO_NR_predios 
        set hectareas_predio = v_hectarea
        where cod_predio = p_cod_predio;
        
        select acciones_predio into v_accione 
        from SA_JS_JO_NR_predios
        where cod_predio = p_cod_predio;
        
        update SA_JS_JO_NR_predios 
        set acciones_predio = v_accione
        where cod_predio = p_cod_predio;

    ELSIF P_OPCION = 2 THEN
        select hectareas_predio into v_hectarea 
        from SA_JS_JO_NR_predios
        where cod_predio = p_cod_predio;

        DELETE FROM SA_JS_JO_NR_DETALLE_PREDIO_CANALES
        WHERE (COD_CANAL = P_COD_CANAL) AND (COD_PREDIO = P_COD_PREDIO);

        update SA_JS_JO_NR_predios 
        set hectareas_predio = v_hectarea
        where cod_predio = p_cod_predio;
        
        select acciones_predio into v_accione 
        from SA_JS_JO_NR_predios
        where cod_predio = p_cod_predio;
        
        update SA_JS_JO_NR_predios 
        set acciones_predio = v_accione
        where cod_predio = p_cod_predio;
    ELSE 
        RAISE_APPLICATION_ERROR(-20001, 'PARAMETROS NO VALIDO UTILIZADOS');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20021, 'Error: No se encontró el canal/predio.');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20022, 'Error inesperado al realizar el vinculo.');
END;
/


--calcuar acciones predio bien
CREATE OR REPLACE TRIGGER trg_actualizar_acciones_predio
before INSERT OR UPDATE OF HECTAREAS_PREDIO
ON SA_JS_JO_NR_PREDIOS
FOR EACH ROW
DECLARE
    v_total_acciones NUMBER := 0;
BEGIN
    -- Si el predio tiene canales asociados
    FOR canal IN (
        SELECT C.FACTOR_CANAL
        FROM SA_JS_JO_NR_DETALLE_PREDIO_CANALES DPC
        JOIN SA_JS_JO_NR_CANALES C ON DPC.COD_CANAL = C.COD_CANAL
        WHERE DPC.COD_PREDIO = :NEW.COD_PREDIO
    ) LOOP
        -- Sumar el producto del factor_canal por hectareas_predio al total de acciones
        v_total_acciones := v_total_acciones + (canal.FACTOR_CANAL * :NEW.HECTAREAS_PREDIO);
    END LOOP;

    -- Si no hay canales asociados, el total de acciones será 0 automáticamente
    :NEW.ACCIONES_PREDIO := v_total_acciones;
END;
/


--calcular deuda usuario

CREATE OR REPLACE TRIGGER trg_calcular_deuda_usuarios-- BIEN
AFTER INSERT OR UPDATE OF ACCIONES_PREDIO
ON SA_JS_JO_NR_PREDIOS
FOR EACH ROW
BEGIN
    -- Declaramos variables para almacenar los valores necesarios
    DECLARE
        v_total_cuota NUMBER;
        v_rut_usuario NUMBER;
        v_acciones_predio NUMBER;
        v_deuda NUMBER;
    BEGIN
        -- Obtenemos el RUT del usuario asociado al predio
        v_rut_usuario := :NEW.RUT_USUARIO;
        
        -- Validamos que el RUT exista para evitar errores
        IF v_rut_usuario IS NOT NULL THEN
            -- Obtenemos el total de la cuota asociada al usuario (a través de la tabla CUOTAS)
            SELECT TOTAL_CUOTA
            INTO v_total_cuota
            FROM SA_JS_JO_NR_CUOTAS
            WHERE COD_CUOTA = (SELECT COD_CUOTA
                              FROM SA_JS_JO_NR_USUARIOS
                              WHERE RUT_USUARIO = v_rut_usuario);
            
            -- Obtenemos las acciones del predio (usamos el valor de la nueva fila)
            v_acciones_predio := :NEW.ACCIONES_PREDIO;
            
            -- Calculamos la deuda multiplicando TOTAL_CUOTA por ACCIONES_PREDIO
            v_deuda := v_total_cuota * v_acciones_predio;
            
            -- Actualizamos el atributo DEUDA en la tabla USUARIOS
            UPDATE SA_JS_JO_NR_USUARIOS
            SET DEUDA = DEUDA + v_deuda
            WHERE RUT_USUARIO = v_rut_usuario;
        END IF;
    END;
END;
/


--historial de pagos
CREATE SEQUENCE SEQ_HISTORIAL_PAGOS
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 1000
    CACHE 50
    NOCYCLE;

CREATE OR REPLACE TRIGGER trg_registrar_pago
AFTER UPDATE OF DEUDA
ON SA_JS_JO_NR_USUARIOS
FOR EACH ROW
WHEN (OLD.DEUDA > NEW.DEUDA)  -- Se activa solo si la deuda se reduce
DECLARE
    v_cod_historial_pago NUMBER;  -- Variable para almacenar el siguiente valor de la secuencia
    v_nombre_pagador VARCHAR2(150);  -- Variable para almacenar el nombre completo del pagador
    v_detalle_pago VARCHAR2(255);  -- Variable para almacenar el mensaje del detalle del pago
    v_pago NUMBER;  -- Cantidad en que se redujo la deuda
BEGIN
    -- Obtener el siguiente valor de la secuencia SEQ_HISTORIAL_PAGOS
    SELECT SEQ_HISTORIAL_PAGOS.NEXTVAL INTO v_cod_historial_pago FROM DUAL;

    -- Construir el nombre completo del pagador
    v_nombre_pagador := :NEW.NOMBRE_USUARIO || ' ' || :NEW.APELLIDO1_USUARIO || ' ' || :NEW.APELLIDO2_USUARIO;

    -- Calcular la cantidad pagada
    v_pago := :OLD.DEUDA - :NEW.DEUDA;

    -- Determinar el detalle del pago
    IF :NEW.DEUDA = 0 THEN
        v_detalle_pago := 'Se ha pagado la totalidad de la deuda exitosamente';
    ELSE
        v_detalle_pago := 'Se ha abonado la cantidad de ' || v_pago || ' exitosamente. La deuda pendiente es de ' || :NEW.DEUDA || '.';
    END IF;

    -- Insertar el registro en la tabla SA_JS_JO_NR_HISTORIAL_PAGOS
    INSERT INTO SA_JS_JO_NR_HISTORIAL_PAGOS (
        COD_HISTORIAL_PAGO,
        NOMBRE_PAGADOR,
        DETALLE_PAGO,
        FECHA_PAGO,
        PAGO,
        RUT_USUARIO
    ) VALUES (
        v_cod_historial_pago,
        v_nombre_pagador,
        v_detalle_pago,
        SYSDATE,
        v_pago,
        :NEW.RUT_USUARIO
    );
END;
/

-- procedimiento de pago
create or replace NONEDITIONABLE PROCEDURE PAGAR(
    p_rut_usuario IN SA_JS_JO_NR_USUARIOS.RUT_USUARIO%TYPE,
    p_cantidad_pago IN NUMBER
)
IS
    v_deuda_actual NUMBER; -- Variable para almacenar la deuda actual del usuario
BEGIN
    -- Validar que el monto del pago no sea negativo
    IF p_cantidad_pago < 0 THEN
        RAISE_APPLICATION_ERROR(-20023, 'Por favor ingrese una cantidad positiva de dinero.');
    END IF;

    -- Obtener la deuda actual del usuario
    SELECT DEUDA
    INTO v_deuda_actual
    FROM SA_JS_JO_NR_USUARIOS
    WHERE RUT_USUARIO = p_rut_usuario;

    -- Validar que la cantidad a pagar no sea mayor a la deuda actual
    IF p_cantidad_pago > v_deuda_actual THEN
        RAISE_APPLICATION_ERROR(-20020, 'Solo puede pagar como máximo la totalidad de su deuda, intente de nuevo por favor.');
    ELSE
        -- Actualizar la deuda del usuario
        UPDATE SA_JS_JO_NR_USUARIOS
        SET DEUDA = DEUDA - p_cantidad_pago
        WHERE RUT_USUARIO = p_rut_usuario;

        -- Confirmar el éxito
        DBMS_OUTPUT.PUT_LINE('Pago exitoso.');
        COMMIT; -- Confirmar los cambios
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20021, 'Error: No se encontró el usuario con el RUT especificado.');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20022, 'Error inesperado al disminuir la deuda.');
END;
/


--REPORTES
--1. Total de deuda por canal
create or replace NONEDITIONABLE PROCEDURE INFORME_DEUDA_CANAL (
    P_RESULTADO OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_RESULTADO FOR
    SELECT
        C.NOMBRE_CANAL,
        SUM(U.DEUDA) AS TOTAL_DEUDA
    FROM
        SA_JS_JO_NR_USUARIOS U
        INNER JOIN SA_JS_JO_NR_PREDIOS P ON U.RUT_USUARIO = P.RUT_USUARIO
        INNER JOIN SA_JS_JO_NR_DETALLE_PREDIO_CANALES DPC ON P.COD_PREDIO = DPC.COD_PREDIO
        INNER JOIN SA_JS_JO_NR_CANALES C ON DPC.COD_CANAL = C.COD_CANAL
    GROUP BY
        C.NOMBRE_CANAL;
END;
/
--2. Proyectos activos y terminados
create or replace NONEDITIONABLE PROCEDURE INFORME_PROYECTOS (
    P_ACTIVOS OUT SYS_REFCURSOR,
    P_TERMINADOS OUT SYS_REFCURSOR
) AS
BEGIN
    -- Proyectos activos
    OPEN P_ACTIVOS FOR
    SELECT
        COD_PROYECTO,
        NOMBRE_PROYECTO,
        DESCRIPCION_PROYECTO,
        FECHA_INICIO_PROYECTO,
        FECHA_FIN_PROYECTO,
        ESTADO_PROYECTO
    FROM
        SA_JS_JO_NR_PROYECTOS
    WHERE
        UPPER(ESTADO_PROYECTO) = 'ACTIVO';

    -- Proyectos terminados
    OPEN P_TERMINADOS FOR
    SELECT
        COD_PROYECTO,
        NOMBRE_PROYECTO,
        DESCRIPCION_PROYECTO,
        FECHA_INICIO_PROYECTO,
        FECHA_FIN_PROYECTO,
        ESTADO_PROYECTO
    FROM
        SA_JS_JO_NR_PROYECTOS
    WHERE
        UPPER(ESTADO_PROYECTO) = 'TERMINADO';
END;
/
--3. Informe de ingresos desde X fecha hasta Y fecha
create or replace NONEDITIONABLE PROCEDURE INFORME_INGRESOS_FECHA (
    P_FECHA_INICIO IN DATE,
    P_FECHA_FIN IN DATE,
    P_RESULTADO OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_RESULTADO FOR
    SELECT
        FECHA_PAGO,
        NOMBRE_PAGADOR,
        DETALLE_PAGO,
        PAGO,
        RUT_USUARIO
    FROM
        SA_JS_JO_NR_HISTORIAL_PAGOS
    WHERE
        FECHA_PAGO BETWEEN P_FECHA_INICIO AND P_FECHA_FIN;
END;
/