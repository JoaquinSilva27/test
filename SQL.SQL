CREATE TABLE SA_JS_JO_NR_REGIONES( --MANTENEDOR LISTO
	COD_REGION NUMBER,
	NOMBRE_REGION VARCHAR2(50),
	CONSTRAINT PK_SA_JS_JO_NR_REGIONES PRIMARY KEY(COD_REGION)
);

CREATE TABLE SA_JS_JO_NR_DIRECCIONES( --MANTENEDOR LISTO
	COD_CALLEN NUMBER,
	CALLE_DIRECCION VARCHAR2(60),
	NUMERO_DIRECCION NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECCIONES PRIMARY KEY(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_COMUNAS( --MANTENEDOR LISTO
	COD_COMUNA NUMBER,
	NOMBRE_COMUNA VARCHAR2(60),
	COD_REGION NUMBER,
	COD_CALLEN NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMUNAS PRIMARY KEY(COD_COMUNA),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_COMUNAS_DIRECCIONES FOREIGN KEY(COD_CALLEN) REFERENCES SA_JS_JO_NR_DIRECCIONES(COD_CALLEN)
);

CREATE TABLE SA_JS_JO_NR_TIPO_CUOTA( --MANTENEDOR LISTO
	COD_TIPO_CUOTA NUMBER,
	TIPO_CUOTA VARCHAR2(20),
	MONTO_CUOTA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_TIPO_CUOTA PRIMARY KEY(COD_TIPO_CUOTA)
);

CREATE TABLE SA_JS_JO_NR_SERVICIOS( --MANTENEDOR LISTO
	COD_SERVICIO NUMBER,
	NOMBRE_SERVICIO VARCHAR2(40),
	CONSTRAINT PK_SA_JS_JO_NR_SERVICIOS PRIMARY KEY(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_COUTAS( --MANTENEDOR LISTO
	COD_CUOTA NUMBER,
	COD_TIPO_CUOTA NUMBER,
	TOTAL_CUOTA NUMBER, --REVISAR
	FECHA_VENCIMIENTO_CUOTA DATE,
	COD_SERVICIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CUOTAS PRIMARY KEY(COD_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_TIPO_CUOTA FOREIGN KEY(COD_TIPO_CUOTA) REFERENCES SA_JS_JO_NR_TIPO_CUOTA(COD_TIPO_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_CUOTAS_SERVICIO FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO)
);

CREATE TABLE SA_JS_JO_NR_PREDIOS( --MANTENEDOR LISTO
	COD_CUOTA NUMBER,
	COD_PREDIO NUMBER, 
	ROL_PREDIO NUMBER,
	HECTAREAS_PREDIO NUMBER,
	ACCIONES_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PREDIOS PRIMARY KEY(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_USUARIO( --MANTENEDOR LISTO
	RUT_USUARIO NUMBER,
	NOMBRE_USUARIO VARCHAR2(100),
	APELLIDO1_USUARIO VARCHAR2(50),
	APELLIDO2_USUARIO VARCHAR2(50),
	COD_REGION NUMBER,
	CORREO_USUARIO VARCHAR2(100),
	TELEFONO_USUARIO NUMBER,
	COD_CUOTA NUMBER,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_USUARIOS PRIMARY KEY(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_REGIONES FOREIGN KEY(COD_REGION) REFERENCES SA_JS_JO_NR_REGIONES(COD_REGION),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_CUOTAS FOREIGN KEY(COD_CUOTA) REFERENCES SA_JS_JO_NR_CUOTAS(COD_CUOTA),
	CONSTRAINT FK_SA_JS_JO_NR_USUARIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_PAGOS(
	COD_HISTORIAL_PAGO NUMBER,
	NOMBRE_PAGADOR VARCHAR2(100),
	DETALLE_PAGO VARCHAR2(200),
	FECHA_PAGO DATE,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_PAGOS PRIMARY KEY(COD_HISTORIAL_PAGO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_PAGOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)
);

CREATE TABLE SA_JS_JO_NR_HISTORIAL_CAMBIOS(
	COD_HISTORIAL_CAMBIO NUMBER,
	DETALLE_CAMBIO VARCHAR2(200),
	FECHA_CAMBIO DATE,
	COD_PREDIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_HISTORIAL_CAMBIOS PRIMARY KEY(COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_HISTORIAL_CAMBIOS_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO)	
);

CREATE TABLE SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIO(
	RUT_USUARIO NUMBER,
	COD_HISTORIAL_CAMBIO NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIO PRIMARY KEY(RUT_USUARIO, COD_HISTORIAL_CAMBIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIO_USUARIOS FOREIGN KEY(RUT_USUARIO) REFERENCES SA_JS_JO_NR_USUARIOS(RUT_USUARIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_HISTORIAL_USUARIO_HISTORIAL_CAMBIOS FOREIGN KEY(COD_HISTORIAL_CAMBIO) REFERENCES SA_JS_JO_NR_HISTORIAL_CAMBIOS(COD_HISTORIAL_CAMBIO)
);

CREATE TABLE SA_JS_JO_NR_SUBZONAS( --MANTENEDOR LISTO
	COD_SUBZONA NUMBER,
	NOMBRE_SUBZONA VARCHAR2(150),
	CONSTRAINT PK_SA_JS_JO_NR_SUBZONAS PRIMARY KEY(COD_SUBZONA)
);

CREATE TABLE SA_JS_JO_NR_ZONAS( --MANTENEDOR LISTO
	COD_ZONA NUMBER,
	NOMBRE_ZONA VARCHAR2(150),
	COD_SUBZONA NUMBER,
	COD_COMUNA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_ZONAS PRIMARY KEY(COD_ZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_SUBZONAS FOREIGN KEY(COD_SUBZONA) REFERENCES SA_JS_JO_NR_SUBZONAS(COD_SUBZONA),
	CONSTRAINT FK_SA_JS_JO_NR_ZONAS_COMUNAS FOREIGN KEY(COD_COMUNA) REFERENCES SA_JS_JO_NR_COMUNAS(COD_COMUNA)
);

CREATE TABLE SA_JS_JO_NR_SECTORES( --MANTENEDOR LISTO
	COD_SECTOR NUMBER, 
	NOMBRE_SECTOR VARCHAR2(100),
	COD_ZONA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_SECTORES PRIMARY KEY(COD_SECTOR),
	CONSTRAINT FK_SA_JS_JO_NR_SECTORES_ZONAS FOREIGN KEY(COD_ZONA) REFERENCES SA_JS_JO_NR_ZONAS(COD_ZONA)
);

CREATE TABLE SA_JS_JO_NR_CANALES( --MANTENEDOR LISTO
	COD_CANAL NUMBER,
	NOMBRE_CANAL VARCHAR2(100),
	FACTOR_CANAL NUMBER,
	COD_SECTOR NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CANALES PRIMARY KEY(COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_CANALES_SECTORES FOREIGN KEY(COD_SECTOR) REFERENCES SA_JS_JO_NR_SECTORES(COD_SECTOR)
);

CREATE TABLE SA_JS_JO_NR_DIRECTIVAS( --MANTENEDOR LISTO
	COD_DIRECTIVA NUMBER,
	NOMBRE_DIRECTIVA VARCHAR2(100),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DIRECTIVAS PRIMARY KEY(COD_DIRECTIVA),
	CONSTRAINT FK_SA_JS_JO_NR_DIRECTIVAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PRESIDENTES( --MANTENEDOR LISTO
	COD_PRESIDENTE NUMBER,
	NOMBRE_PRESIDENTE VARCHAR2(100),
	APELLIDO1_PRESIDENTE VARCHAR2(50),
	APELLIDO2_PRESIDENTE VARCHAR2(50),
	COD_DIRECTIVA NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PRESIDENTES PRIMARY KEY(COD_PRESIDENTE),
	CONSTRAINT FK_SA_JS_JO_NR_PRESIDENTES_DIRECTIVAS FOREIGN KEY(COD_DIRECTIVA) REFERENCES SA_JS_JO_NR_DIRECTIVAS(COD_DIRECTIVA)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_SERVICIO_CANAL(
	COD_SERVICIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_SERVICIO_CANAL PRIMARY KEY(COD_SERVICIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANAL_SERVICIOS FOREIGN KEY(COD_SERVICIO) REFERENCES SA_JS_JO_NR_SERVICIOS(COD_SERVICIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_SERVICIO_CANAL_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_DETALLE_PREDIO_CANAL(
	COD_PREDIO NUMBER,
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_DETALLE_PREDIO_CANAL PRIMARY KEY(COD_PREDIO, COD_CANAL),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANAL_PREDIOS FOREIGN KEY(COD_PREDIO) REFERENCES SA_JS_JO_NR_PREDIOS(COD_PREDIO),
	CONSTRAINT FK_SA_JS_JO_NR_DETALLE_PREDIO_CANAL_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_PROYECTOS( --MANTENEDOR LISTO
	COD_PROYECTO NUMBER,
	NOMBRE_PROYECTO VARCHAR2(100),
	DESCRIPCION_PROYECTO VARCHAR2(200),
	FECHA_INICIO_PROYECTO DATE,
	FECHA_FIN_PROYECTO DATE,
	ESTADO_PROYECTO VARCHAR2(20),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_PROYECTOS PRIMARY KEY(COD_PROYECTO),
	CONSTRAINT FK_SA_JS_JO_NR_PROYECTOS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_COMPUERTAS( --MANTENEDOR LISTO
	COD_COMPUERTA NUMBER,
	KILOMETRAJE_COMPUERTA NUMBER,
	DESCRIPCION_COMPUERTA VARCHAR2(200),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_COMPUERTAS PRIMARY KEY(COD_COMPUERTA),
	CONSTRAINT FK_SA_JS_JO_NR_COMPUERTAS_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

CREATE TABLE SA_JS_JO_NR_CELADORES( --MANTENEDOR LISTO
	COD_CELADOR NUMBER,
	NOMBRE_CELADOR VARCHAR2(100),
	APELLIDO1_CELADOR VARCHAR2(50),
	APELLIDO2_CELADOR VARCHAR2(50),
	COD_CANAL NUMBER,
	CONSTRAINT PK_SA_JS_JO_NR_CELADORES PRIMARY KEY(COD_CELADOR),
	CONSTRAINT FK_SA_JS_JO_NR_CELADORES_CANALES FOREIGN KEY(COD_CANAL) REFERENCES SA_JS_JO_NR_CANALES(COD_CANAL)
);

-- MANTENEDORES

-- REGIONES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_REGIONES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERT_REGION(
    P_NOMBRE_REGION VARCHAR2
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_REGIONES (COD_REGION, NOMBRE_REGION)
    VALUES (SEQ_SA_JS_JO_NR_REGIONES.NEXTVAL, P_NOMBRE_REGION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501,'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010,'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_REGIONES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_REGION, NOMBRE_REGION FROM SA_JS_JO_NR_REGIONES;
END LEER_REGIONES;
/

CREATE OR REPLACE PROCEDURE UPDATE_REGION(
    P_COD_REGION NUMBER,
    P_NOMBRE_REGION VARCHAR2
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

	IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Región no encontrada');
    
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	UPDATE SA_JS_JO_NR_REGIONES
    	SET NOMBRE_REGION = P_NOMBRE_REGION
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_REGION(
    P_COD_REGION NUMBER
) 
IS
	CONTADOR NUMBER := 0;
BEGIN
	SELECT COUNT(*) INTO CONTADOR
	FROM SA_JS_JO_NR_REGIONES
	WHERE COD_REGION = P_COD_REGION;

    IF (CONTADOR = 0) THEN
        RAISE_APPLICATION_ERROR(-20002, 'Región no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_REGIONES IN ROW EXCLUSIVE MODE;
    	DELETE FROM SA_JS_JO_NR_REGIONES
    	WHERE COD_REGION = P_COD_REGION;
    	COMMIT;
    END IF;
EXCEPTION
	WHEN OTHERS THEN
        ROLLBACK;
    	RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

--DIRECCIONES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_DIRECCIONES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_DIRECCION(
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_DIRECCIONES (COD_CALLEN, CALLE_DIRECCION, NUMERO_DIRECCION)
    VALUES (SEQ_SA_JS_JO_NR_DIRECCIONES.NEXTVAL, P_CALLE_DIRECCION, P_NUMERO_DIRECCION);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECCIONES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CALLEN, CALLE_DIRECCION, NUMERO_DIRECCION FROM SA_JS_JO_NR_DIRECCIONES;
END LEER_DIRECCIONES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECCION(
    P_COD_CALLEN NUMBER,
    P_CALLE_DIRECCION VARCHAR2,
    P_NUMERO_DIRECCION NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        UPDATE SA_JS_JO_NR_DIRECCIONES
        SET CALLE_DIRECCION = P_CALLE_DIRECCION,
            NUMERO_DIRECCION = P_NUMERO_DIRECCION
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECCION(
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECCIONES
    WHERE COD_CALLEN = P_COD_CALLEN;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Dirección no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_DIRECCIONES IN ROW EXCLUSIVE MODE;
        DELETE FROM SA_JS_JO_NR_DIRECCIONES
        WHERE COD_CALLEN = P_COD_CALLEN;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación');
END;
/

-- COMUNAS 
CREATE SEQUENCE SEQ_SA_JS_JO_NR_COMUNAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 1000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_COMUNA(
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_COMUNAS (COD_COMUNA, NOMBRE_COMUNA, COD_REGION, COD_CALLEN)
    VALUES (SEQ_SA_JS_JO_NR_COMUNAS.NEXTVAL, P_NOMBRE_COMUNA, P_COD_REGION, P_COD_CALLEN);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la comuna');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMUNAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_COMUNA, NOMBRE_COMUNA, COD_REGION, COD_CALLEN FROM SA_JS_JO_NR_COMUNAS;
END LEER_COMUNAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMUNA(
    P_COD_COMUNA NUMBER,
    P_NOMBRE_COMUNA VARCHAR2,
    P_COD_REGION NUMBER,
    P_COD_CALLEN NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_COMUNAS
        SET NOMBRE_COMUNA = P_NOMBRE_COMUNA,
            COD_REGION = P_COD_REGION,
            COD_CALLEN = P_COD_CALLEN
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la comuna');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMUNA(
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMUNAS
    WHERE COD_COMUNA = P_COD_COMUNA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Comuna no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COMUNAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_COMUNAS
        WHERE COD_COMUNA = P_COD_COMUNA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la comuna');
END;
/

-- TIPO CUOTA
CREATE SEQUENCE SEQ_SA_JS_JO_NR_TIPO_CUOTA 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 1000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_TIPO_CUOTA(
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTA IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_TIPO_CUOTA (COD_TIPO_CUOTA, TIPO_CUOTA, MONTO_CUOTA)
    VALUES (SEQ_SA_JS_JO_NR_TIPO_CUOTA.NEXTVAL, P_TIPO_CUOTA, P_MONTO_CUOTA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_TIPO_CUOTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_TIPO_CUOTA, TIPO_CUOTA, MONTO_CUOTA FROM SA_JS_JO_NR_TIPO_CUOTA;
END LEER_TIPO_CUOTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_TIPO_CUOTA(
    P_COD_TIPO_CUOTA NUMBER,
    P_TIPO_CUOTA VARCHAR2,
    P_MONTO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTA
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTA IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_TIPO_CUOTA
        SET TIPO_CUOTA = P_TIPO_CUOTA,
            MONTO_CUOTA = P_MONTO_CUOTA
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del tipo de cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_TIPO_CUOTA(
    P_COD_TIPO_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_TIPO_CUOTA
    WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Tipo de cuota no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_TIPO_CUOTA IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_TIPO_CUOTA
        WHERE COD_TIPO_CUOTA = P_COD_TIPO_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del tipo de cuota');
END;
/

-- SERVICIOS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_SERVICIOS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 1000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_SERVICIO(
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_SERVICIOS (COD_SERVICIO, NOMBRE_SERVICIO)
    VALUES (SEQ_SA_JS_JO_NR_SERVICIOS.NEXTVAL, P_NOMBRE_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el servicio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SERVICIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SERVICIO, NOMBRE_SERVICIO FROM SA_JS_JO_NR_SERVICIOS;
END LEER_SERVICIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SERVICIO(
    P_COD_SERVICIO NUMBER,
    P_NOMBRE_SERVICIO VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_SERVICIOS
        SET NOMBRE_SERVICIO = P_NOMBRE_SERVICIO
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del servicio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SERVICIO(
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SERVICIOS
    WHERE COD_SERVICIO = P_COD_SERVICIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Servicio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_SERVICIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_SERVICIOS
        WHERE COD_SERVICIO = P_COD_SERVICIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del servicio');
END;
/

-- CUOTAS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_COUTAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_CUOTA(
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_COUTAS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_COUTAS (COD_CUOTA, COD_TIPO_CUOTA, TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA, COD_SERVICIO)
    VALUES (SEQ_SA_JS_JO_NR_COUTAS.NEXTVAL, P_COD_TIPO_CUOTA, P_TOTAL_CUOTA, P_FECHA_VENCIMIENTO_CUOTA, P_COD_SERVICIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la cuota');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COUTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CUOTA, COD_TIPO_CUOTA, TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA, COD_SERVICIO 
        FROM SA_JS_JO_NR_COUTAS;
END LEER_COUTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CUOTA(
    P_COD_CUOTA NUMBER,
    P_COD_TIPO_CUOTA NUMBER,
    P_TOTAL_CUOTA NUMBER,
    P_FECHA_VENCIMIENTO_CUOTA DATE,
    P_COD_SERVICIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COUTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COUTAS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_COUTAS
        SET COD_TIPO_CUOTA = P_COD_TIPO_CUOTA,
            TOTAL_CUOTA = P_TOTAL_CUOTA,
            FECHA_VENCIMIENTO_CUOTA = P_FECHA_VENCIMIENTO_CUOTA,
            COD_SERVICIO = P_COD_SERVICIO
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la cuota');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CUOTA(
    P_COD_CUOTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COUTAS
    WHERE COD_CUOTA = P_COD_CUOTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Cuota no encontrada');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_COUTAS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_COUTAS
        WHERE COD_CUOTA = P_COD_CUOTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la cuota');
END;
/

--PREDIOS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_PREDIOS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_PREDIO(
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER
) 
IS
BEGIN
	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
    INSERT INTO SA_JS_JO_NR_PREDIOS (COD_PREDIO, ROL_PREDIO, HECTAREAS_PREDIO, ACCIONES_PREDIO)
    VALUES (SEQ_SA_JS_JO_NR_PREDIOS.NEXTVAL, P_ROL_PREDIO, P_HECTAREAS_PREDIO, P_ACCIONES_PREDIO);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el predio');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PREDIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PREDIO, ROL_PREDIO, HECTAREAS_PREDIO, ACCIONES_PREDIO FROM SA_JS_JO_NR_PREDIOS;
END LEER_PREDIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PREDIO(
    P_COD_PREDIO NUMBER,
    P_ROL_PREDIO NUMBER,
    P_HECTAREAS_PREDIO NUMBER,
    P_ACCIONES_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Actualización si existe
        UPDATE SA_JS_JO_NR_PREDIOS
        SET ROL_PREDIO = P_ROL_PREDIO,
            HECTAREAS_PREDIO = P_HECTAREAS_PREDIO,
            ACCIONES_PREDIO = P_ACCIONES_PREDIO
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del predio');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PREDIO(
    P_COD_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PREDIOS
    WHERE COD_PREDIO = P_COD_PREDIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Predio no encontrado');
    ELSE
    	LOCK TABLE SA_JS_JO_NR_PREDIOS IN ROW EXCLUSIVE MODE;
        -- Eliminación si existe
        DELETE FROM SA_JS_JO_NR_PREDIOS
        WHERE COD_PREDIO = P_COD_PREDIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del predio');
END;
/

-- USUARIO
CREATE SEQUENCE SEQ_SA_JS_JO_NR_USUARIO 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_USUARIO(
    P_NOMBRE_USUARIO VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_COD_PREDIO NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_USUARIO IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_USUARIO (
        RUT_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO,
        COD_REGION, CORREO_USUARIO, TELEFONO_USUARIO, COD_CUOTA, COD_PREDIO
    )
    VALUES (
        SEQ_SA_JS_JO_NR_USUARIO.NEXTVAL, P_NOMBRE_USUARIO, P_APELLIDO1_USUARIO, 
        P_APELLIDO2_USUARIO, P_COD_REGION, P_CORREO_USUARIO, P_TELEFONO_USUARIO, 
        P_COD_CUOTA, P_COD_PREDIO
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el usuario');
END;
/

CREATE OR REPLACE PROCEDURE LEER_USUARIOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT RUT_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO, 
               COD_REGION, CORREO_USUARIO, TELEFONO_USUARIO, COD_CUOTA, COD_PREDIO
        FROM SA_JS_JO_NR_USUARIO;
END LEER_USUARIOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_USUARIO(
    P_RUT_USUARIO NUMBER,
    P_NOMBRE_USUARIO VARCHAR2,
    P_APELLIDO1_USUARIO VARCHAR2,
    P_APELLIDO2_USUARIO VARCHAR2,
    P_COD_REGION NUMBER,
    P_CORREO_USUARIO VARCHAR2,
    P_TELEFONO_USUARIO NUMBER,
    P_COD_CUOTA NUMBER,
    P_COD_PREDIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIO
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIO IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_USUARIO
        SET NOMBRE_USUARIO = P_NOMBRE_USUARIO,
            APELLIDO1_USUARIO = P_APELLIDO1_USUARIO,
            APELLIDO2_USUARIO = P_APELLIDO2_USUARIO,
            COD_REGION = P_COD_REGION,
            CORREO_USUARIO = P_CORREO_USUARIO,
            TELEFONO_USUARIO = P_TELEFONO_USUARIO,
            COD_CUOTA = P_COD_CUOTA,
            COD_PREDIO = P_COD_PREDIO
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del usuario');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_USUARIO(
    P_RUT_USUARIO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_USUARIO
    WHERE RUT_USUARIO = P_RUT_USUARIO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Usuario no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_USUARIO IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_USUARIO
        WHERE RUT_USUARIO = P_RUT_USUARIO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del usuario');
END;
/

-- SUBZONAS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_SUBZONAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_SUBZONA(
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SUBZONAS (COD_SUBZONA, NOMBRE_SUBZONA)
    VALUES (SEQ_SA_JS_JO_NR_SUBZONAS.NEXTVAL, P_NOMBRE_SUBZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la subzona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SUBZONAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SUBZONA, NOMBRE_SUBZONA FROM SA_JS_JO_NR_SUBZONAS;
END LEER_SUBZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SUBZONA(
    P_COD_SUBZONA NUMBER,
    P_NOMBRE_SUBZONA VARCHAR2
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SUBZONAS
        SET NOMBRE_SUBZONA = P_NOMBRE_SUBZONA
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la subzona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SUBZONA(
    P_COD_SUBZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SUBZONAS
    WHERE COD_SUBZONA = P_COD_SUBZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Subzona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SUBZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SUBZONAS
        WHERE COD_SUBZONA = P_COD_SUBZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la subzona');
END;
/

-- ZONAS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_ZONAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_ZONA(
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_ZONAS (COD_ZONA, NOMBRE_ZONA, COD_SUBZONA, COD_COMUNA)
    VALUES (SEQ_SA_JS_JO_NR_ZONAS.NEXTVAL, P_NOMBRE_ZONA, P_COD_SUBZONA, P_COD_COMUNA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la zona');
END;
/

CREATE OR REPLACE PROCEDURE LEER_ZONAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_ZONA, NOMBRE_ZONA, COD_SUBZONA, COD_COMUNA FROM SA_JS_JO_NR_ZONAS;
END LEER_ZONAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_ZONA(
    P_COD_ZONA NUMBER,
    P_NOMBRE_ZONA VARCHAR2,
    P_COD_SUBZONA NUMBER,
    P_COD_COMUNA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_ZONAS
        SET NOMBRE_ZONA = P_NOMBRE_ZONA,
            COD_SUBZONA = P_COD_SUBZONA,
            COD_COMUNA = P_COD_COMUNA
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la zona');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_ZONA(
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_ZONAS
    WHERE COD_ZONA = P_COD_ZONA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Zona no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_ZONAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_ZONAS
        WHERE COD_ZONA = P_COD_ZONA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la zona');
END;
/

-- SECTORES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_SECTORES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_SECTOR(
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_SECTORES (COD_SECTOR, NOMBRE_SECTOR, COD_ZONA)
    VALUES (SEQ_SA_JS_JO_NR_SECTORES.NEXTVAL, P_NOMBRE_SECTOR, P_COD_ZONA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el sector');
END;
/

CREATE OR REPLACE PROCEDURE LEER_SECTORES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_SECTOR, NOMBRE_SECTOR, COD_ZONA FROM SA_JS_JO_NR_SECTORES;
END LEER_SECTORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_SECTOR(
    P_COD_SECTOR NUMBER,
    P_NOMBRE_SECTOR VARCHAR2,
    P_COD_ZONA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_SECTORES
        SET NOMBRE_SECTOR = P_NOMBRE_SECTOR,
            COD_ZONA = P_COD_ZONA
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del sector');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_SECTOR(
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_SECTORES
    WHERE COD_SECTOR = P_COD_SECTOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Sector no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_SECTORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_SECTORES
        WHERE COD_SECTOR = P_COD_SECTOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del sector');
END;
/

-- CANALES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_CANALES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_CANAL(
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CANALES (COD_CANAL, NOMBRE_CANAL, FACTOR_CANAL, COD_SECTOR)
    VALUES (SEQ_SA_JS_JO_NR_CANALES.NEXTVAL, P_NOMBRE_CANAL, P_FACTOR_CANAL, P_COD_SECTOR);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el canal');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CANALES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CANAL, NOMBRE_CANAL, FACTOR_CANAL, COD_SECTOR FROM SA_JS_JO_NR_CANALES;
END LEER_CANALES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CANAL(
    P_COD_CANAL NUMBER,
    P_NOMBRE_CANAL VARCHAR2,
    P_FACTOR_CANAL NUMBER,
    P_COD_SECTOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CANALES
        SET NOMBRE_CANAL = P_NOMBRE_CANAL,
            FACTOR_CANAL = P_FACTOR_CANAL,
            COD_SECTOR = P_COD_SECTOR
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del canal');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CANAL(
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CANALES
    WHERE COD_CANAL = P_COD_CANAL;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Canal no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CANALES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CANALES
        WHERE COD_CANAL = P_COD_CANAL;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del canal');
END;
/

-- DIRECTIVAS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_DIRECTIVAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_DIRECTIVA(
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_DIRECTIVAS (COD_DIRECTIVA, NOMBRE_DIRECTIVA, COD_CANAL)
    VALUES (SEQ_SA_JS_JO_NR_DIRECTIVAS.NEXTVAL, P_NOMBRE_DIRECTIVA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la directiva');
END;
/

CREATE OR REPLACE PROCEDURE LEER_DIRECTIVAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_DIRECTIVA, NOMBRE_DIRECTIVA, COD_CANAL FROM SA_JS_JO_NR_DIRECTIVAS;
END LEER_DIRECTIVAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_DIRECTIVA(
    P_COD_DIRECTIVA NUMBER,
    P_NOMBRE_DIRECTIVA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_DIRECTIVAS
        SET NOMBRE_DIRECTIVA = P_NOMBRE_DIRECTIVA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la directiva');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_DIRECTIVA(
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_DIRECTIVAS
    WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Directiva no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_DIRECTIVAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_DIRECTIVAS
        WHERE COD_DIRECTIVA = P_COD_DIRECTIVA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la directiva');
END;
/

-- PRESIDENTES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_PRESIDENTES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_PRESIDENTE(
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PRESIDENTES (COD_PRESIDENTE, NOMBRE_PRESIDENTE, APELLIDO1_PRESIDENTE, APELLIDO2_PRESIDENTE, COD_DIRECTIVA)
    VALUES (SEQ_SA_JS_JO_NR_PRESIDENTES.NEXTVAL, P_NOMBRE_PRESIDENTE, P_APELLIDO1_PRESIDENTE, P_APELLIDO2_PRESIDENTE, P_COD_DIRECTIVA);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el presidente');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PRESIDENTES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PRESIDENTE, NOMBRE_PRESIDENTE, APELLIDO1_PRESIDENTE, APELLIDO2_PRESIDENTE, COD_DIRECTIVA 
        FROM SA_JS_JO_NR_PRESIDENTES;
END LEER_PRESIDENTES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PRESIDENTE(
    P_COD_PRESIDENTE NUMBER,
    P_NOMBRE_PRESIDENTE VARCHAR2,
    P_APELLIDO1_PRESIDENTE VARCHAR2,
    P_APELLIDO2_PRESIDENTE VARCHAR2,
    P_COD_DIRECTIVA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PRESIDENTES
        SET NOMBRE_PRESIDENTE = P_NOMBRE_PRESIDENTE,
            APELLIDO1_PRESIDENTE = P_APELLIDO1_PRESIDENTE,
            APELLIDO2_PRESIDENTE = P_APELLIDO2_PRESIDENTE,
            COD_DIRECTIVA = P_COD_DIRECTIVA
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del presidente');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PRESIDENTE(
    P_COD_PRESIDENTE NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PRESIDENTES
    WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Presidente no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PRESIDENTES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PRESIDENTES
        WHERE COD_PRESIDENTE = P_COD_PRESIDENTE;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del presidente');
END;
/

-- PROYECTOS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_PROYECTOS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_PROYECTO(
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_PROYECTOS (
        COD_PROYECTO, NOMBRE_PROYECTO, DESCRIPCION_PROYECTO, 
        FECHA_INICIO_PROYECTO, FECHA_FIN_PROYECTO, ESTADO_PROYECTO, COD_CANAL
    )
    VALUES (
        SEQ_SA_JS_JO_NR_PROYECTOS.NEXTVAL, P_NOMBRE_PROYECTO, P_DESCRIPCION_PROYECTO, 
        P_FECHA_INICIO_PROYECTO, P_FECHA_FIN_PROYECTO, P_ESTADO_PROYECTO, P_COD_CANAL
    );
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el proyecto');
END;
/

CREATE OR REPLACE PROCEDURE LEER_PROYECTOS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_PROYECTO, NOMBRE_PROYECTO, DESCRIPCION_PROYECTO, 
               FECHA_INICIO_PROYECTO, FECHA_FIN_PROYECTO, ESTADO_PROYECTO, COD_CANAL 
        FROM SA_JS_JO_NR_PROYECTOS;
END LEER_PROYECTOS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_PROYECTO(
    P_COD_PROYECTO NUMBER,
    P_NOMBRE_PROYECTO VARCHAR2,
    P_DESCRIPCION_PROYECTO VARCHAR2,
    P_FECHA_INICIO_PROYECTO DATE,
    P_FECHA_FIN_PROYECTO DATE,
    P_ESTADO_PROYECTO VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_PROYECTOS
        SET NOMBRE_PROYECTO = P_NOMBRE_PROYECTO,
            DESCRIPCION_PROYECTO = P_DESCRIPCION_PROYECTO,
            FECHA_INICIO_PROYECTO = P_FECHA_INICIO_PROYECTO,
            FECHA_FIN_PROYECTO = P_FECHA_FIN_PROYECTO,
            ESTADO_PROYECTO = P_ESTADO_PROYECTO,
            COD_CANAL = P_COD_CANAL
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del proyecto');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_PROYECTO(
    P_COD_PROYECTO NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_PROYECTOS
    WHERE COD_PROYECTO = P_COD_PROYECTO;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Proyecto no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_PROYECTOS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_PROYECTOS
        WHERE COD_PROYECTO = P_COD_PROYECTO;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del proyecto');
END;
/

-- COMPUERTAS
CREATE SEQUENCE SEQ_SA_JS_JO_NR_COMPUERTAS 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_COMPUERTA(
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_COMPUERTAS (COD_COMPUERTA, KILOMETRAJE_COMPUERTA, DESCRIPCION_COMPUERTA, COD_CANAL)
    VALUES (SEQ_SA_JS_JO_NR_COMPUERTAS.NEXTVAL, P_KILOMETRAJE_COMPUERTA, P_DESCRIPCION_COMPUERTA, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE LEER_COMPUERTAS(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_COMPUERTA, KILOMETRAJE_COMPUERTA, DESCRIPCION_COMPUERTA, COD_CANAL FROM SA_JS_JO_NR_COMPUERTAS;
END LEER_COMPUERTAS;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_COMPUERTA(
    P_COD_COMPUERTA NUMBER,
    P_KILOMETRAJE_COMPUERTA NUMBER,
    P_DESCRIPCION_COMPUERTA VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_COMPUERTAS
        SET KILOMETRAJE_COMPUERTA = P_KILOMETRAJE_COMPUERTA,
            DESCRIPCION_COMPUERTA = P_DESCRIPCION_COMPUERTA,
            COD_CANAL = P_COD_CANAL
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización de la compuerta');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_COMPUERTA(
    P_COD_COMPUERTA NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_COMPUERTAS
    WHERE COD_COMPUERTA = P_COD_COMPUERTA;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Compuerta no encontrada');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_COMPUERTAS IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_COMPUERTAS
        WHERE COD_COMPUERTA = P_COD_COMPUERTA;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación de la compuerta');
END;
/

-- CELADORES
CREATE SEQUENCE SEQ_SA_JS_JO_NR_CELADORES 
START WITH 1 
INCREMENT BY 1
MINVALUE 1
MAXVALUE 10000
CACHE 50
NOCYCLE;

CREATE OR REPLACE PROCEDURE INSERTAR_CELADOR(
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
BEGIN
    -- Bloqueo de la tabla para control de concurrencia
    LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;

    -- Inserción del registro
    INSERT INTO SA_JS_JO_NR_CELADORES (COD_CELADOR, NOMBRE_CELADOR, APELLIDO1_CELADOR, APELLIDO2_CELADOR, COD_CANAL)
    VALUES (SEQ_SA_JS_JO_NR_CELADORES.NEXTVAL, P_NOMBRE_CELADOR, P_APELLIDO1_CELADOR, P_APELLIDO2_CELADOR, P_COD_CANAL);
    COMMIT;
EXCEPTION
    WHEN PROGRAM_ERROR THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-6501, 'ERROR DE PROGRAMA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado al insertar el celador');
END;
/

CREATE OR REPLACE PROCEDURE LEER_CELADORES(
    P_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN P_CURSOR FOR 
        SELECT COD_CELADOR, NOMBRE_CELADOR, APELLIDO1_CELADOR, APELLIDO2_CELADOR, COD_CANAL 
        FROM SA_JS_JO_NR_CELADORES;
END LEER_CELADORES;
/

CREATE OR REPLACE PROCEDURE ACTUALIZAR_CELADOR(
    P_COD_CELADOR NUMBER,
    P_NOMBRE_CELADOR VARCHAR2,
    P_APELLIDO1_CELADOR VARCHAR2,
    P_APELLIDO2_CELADOR VARCHAR2,
    P_COD_CANAL NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Actualización de la fila específica
        UPDATE SA_JS_JO_NR_CELADORES
        SET NOMBRE_CELADOR = P_NOMBRE_CELADOR,
            APELLIDO1_CELADOR = P_APELLIDO1_CELADOR,
            APELLIDO2_CELADOR = P_APELLIDO2_CELADOR,
            COD_CANAL = P_COD_CANAL
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la actualización del celador');
END;
/

CREATE OR REPLACE PROCEDURE ELIMINAR_CELADOR(
    P_COD_CELADOR NUMBER
) 
IS
    CONTADOR NUMBER := 0;
BEGIN
    -- Verificación de existencia
    SELECT COUNT(*) INTO CONTADOR
    FROM SA_JS_JO_NR_CELADORES
    WHERE COD_CELADOR = P_COD_CELADOR;

    IF CONTADOR = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Celador no encontrado');
    ELSE
        -- Bloqueo de la tabla para control de concurrencia
        LOCK TABLE SA_JS_JO_NR_CELADORES IN ROW EXCLUSIVE MODE;
        
        -- Eliminación de la fila específica
        DELETE FROM SA_JS_JO_NR_CELADORES
        WHERE COD_CELADOR = P_COD_CELADOR;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20010, 'Ocurrió un error inesperado durante la eliminación del celador');
END;
/

-- Funciones

-- Funcion para calcular interes
CREATE OR REPLACE FUNCTION calcular_total_con_interes(
    p_cod_cuota NUMBER
) RETURN NUMBER IS
    v_total_con_interes NUMBER := 0;
    v_dias_vencidos NUMBER := 0;
    v_total_cuota NUMBER;
    v_fecha_vencimiento DATE;
BEGIN
    SELECT TOTAL_CUOTA, FECHA_VENCIMIENTO_CUOTA 
    INTO v_total_cuota, v_fecha_vencimiento
    FROM SA_JS_JO_NR_CUOTAS
    WHERE COD_CUOTA = p_cod_cuota;

    IF v_fecha_vencimiento < SYSDATE THEN
        v_dias_vencidos := SYSDATE - v_fecha_vencimiento;
    END IF;
    -- Calcular el total con interés (0.05% por día de atraso) (cambiar)
    v_total_con_interes := v_total_cuota + (v_total_cuota * 0.0005 * v_dias_vencidos);
    RETURN v_total_con_interes;
END;

-- EJEMPLO DE USO:
SELECT COD_CUOTA,
       TOTAL_CUOTA,
       calcular_total_con_interes(COD_CUOTA) AS TOTAL_CON_INTERES
FROM SA_JS_JO_NR_CUOTAS
WHERE COD_CUOTA = 101;  -- Reemplaza 101 con el código de la cuota que deseas consultar


-- fUNCION PARA VERIFICAR DISPONIBILIDAD DEL PROYECTO 
CREATE OR REPLACE FUNCTION verificar_disponibilidad_proyecto(
    p_cod_proyecto NUMBER
) RETURN BOOLEAN IS
    v_disponible BOOLEAN := TRUE;
    v_estado VARCHAR2(20);
    v_cuotas_vencidas NUMBER;
BEGIN
    -- Verificar si el proyecto está activo
    SELECT estado INTO v_estado
    FROM SA_JS_JO_NR_PROYECTOS  -- Suponiendo que existe una tabla de proyectos
    WHERE cod_proyecto = p_cod_proyecto;

    IF v_estado != 'Activo' THEN
        v_disponible := FALSE;
    END IF;
    RETURN v_disponible;
END verificar_disponibilidad_proyecto;

-- GESTORES

1. Gestor de Cuotas Pendientes por Usuario
Este gestor calcula el total de cuotas pendientes por usuario. Puede ser útil para monitorear qué usuarios tienen pagos atrasados.
2. Gestor de Proyectos Activos por Canal
Este gestor obtiene la lista de proyectos activos (es decir, proyectos en curso) por cada canal.
3. Gestor de Historial de Pagos por Predio
Este gestor devuelve un historial de pagos para cada predio, útil para ver el historial de contribuciones de cada uno.
4. Gestor de Servicios por Canal
Este gestor muestra todos los servicios asociados a cada canal, mostrando su relación en detalle.
5. Gestor de Celadores por Canal
Este gestor muestra la lista de celadores asignados a cada canal, lo cual es útil para analizar la distribución de personal.


--REPORTES

1. Reporte de Usuarios y Cuotas Pendientes
Este reporte muestra a los usuarios que tienen cuotas pendientes, mostrando la cuota y fecha de vencimiento y interes acumulado.
2. Reporte de Proyectos por Estado
Este reporte muestra el estado de cada proyecto en la base de datos, organizado por estado.
3. Reporte de Historial de Pagos
Este reporte muestra todos los pagos realizados para un periodo específico. Se puede adaptar para usar un parámetro de fechas para limitar el periodo.